%%%%%%%%%%%%%%%%%%%%%%% file typeinst.tex %%%%%%%%%%%%%%%%%%%%%%%%%
%
% This is the LaTeX source for the instructions to authors using
% the LaTeX document class 'llncs.cls' for contributions to
% the Lecture Notes in Computer Sciences series.
% http://www.springer.com/lncs       Springer Heidelberg 2006/05/04
%
% It may be used as a template for your own input - copy it
% to a new file with a new name and use it as the basis
% for your article.
%
% NB: the document class 'llncs' has its own and detailed documentation, see
% ftp://ftp.springer.de/data/pubftp/pub/tex/latex/llncs/latex2e/llncsdoc.pdf
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\documentclass[runningheads,a4paper]{llncs}
\documentclass[a4paper]{llncs}

%\usepackage{amssymb}
%\setcounter{tocdepth}{3}
%\usepackage{graphicx}
\usepackage{url}
\usepackage[utf8]{inputenc}
\usepackage{todonotes}
%\usepackage{hyperref}
%\usepackage{booktabs}
%\usepackage{subfig}
%\usepackage{array}
\usepackage[portuges]{babel}

% \newcommand{\papertitle}{A Distributed Computing Framework for Heterogeneous Environments}


\newcommand{\papertitle}{PCap com filtragem orientada ao processo}

%\newcommand{\papertitle}{Leveraging GPUs for Scientific Computing}

%\hypersetup{pdfborder=0 0 0,
%            pdfauthor={Nuno Martins \and Vítor Duarte},
%%            pdfcreator=,
%            pdfkeywords={Pcap, linux, monitorização,},
%%            pdfsubject=TesteSubject,
%            pdftitle={\papertitle}
%           }


\urldef{\mailsa}\path|nuno.m.g.martins@gmail.com|
\urldef{\mailsb}\path|vad@di.fct.unl.pt|    

\newcommand{\keywords}[1]{\par\addvspace\baselineskip
\noindent\keywordname\enspace\ignorespaces#1}

\newcommand{\td}[1]{\todo[inline]{#1}}


\begin{document}

\mainmatter  % start of an individual contribution

% first the title is needed
\title{\papertitle}

\author{Nuno Martins\inst{1} e Vítor Duarte\inst{2}}
%
\authorrunning{\papertitle}
% (feature abused for this document to repeat the title also on left hand pages)

% the affiliations are given next; don't give your e-mail address
% unless you accept that it will be published
\institute{\email{nuno.m.g.martins@gmail.com} \and \email{vad@di.fct.unl.pt}\\
CITI --- Departamento de Informática,\\
Faculdade de Ciências e Tecnologia,\\
Universidade Nova de Lisboa, Portugal}
%\mailsa \qquad \mailsb}

%
% NB: a more complex sample for affiliations and the mapping to the
% corresponding authors can be found in the file "llncs.dem"
% (search for the string "\mainmatter" where a contribution starts).
% "llncs.dem" accompanies the docume\label{•} nt class "llncs.cls".
%

%\toctitle{Lecture Notes in Computer Science}
%\tocauthor{Authors' Instructions}
\maketitle

\begin{abstract}

A monitorização do comportamento dos processos é uma das melhores formas de compreender, detectar erros e avaliar o seu desempenho durante a sua execução real, ainda mais se não for possível aceder ao seu código fonte.
No entanto, o impacto no desempenho e comportamento pode ser bastante significativo. O caso das interacções via rede não é excepção, sendo o pcap um dos sistemas mais populares para monitorizar/capturar o tráfego de rede ao nível do SO. Este trabalho baseia-se nesse sistema e no suporte dado pelo núcleo Linux, para permitir capturar as interacções via rede de processos específicos, procurando também limitar o impacto negativo desta monitorização.
Predende-se que sem conhecer \emph{à priori} quais os portos que irão ser utilizados pelo processo, e sem necessitar de capturar todo o tráfego que pasa pela rede obter apenas os pacotes referentes ao processo alvo. 
  Para tal, foi criada uma forma de filtragem no \emph{bpf-filters}, usados pelo pcap que, dinamicamente, através da monitorização das chamadas ao sistema do processo, permite manter os endereços e portos em utilização pelo processo alvo e capturar apenas o seu tráfego. Deste modo é possível obter apenas os dados relevantes, diminuir o volume de dados transferidos entre o núcleo de sistema e a ferramenta que monitoriza/analisa o processo, assim como um menor número de trocas de contexto, com vantagens funcionais e de desempenho. 


%As chamadas ao sistema de comunicação com o exterior são monitorizadas através do \textit{KProbes}. Este sistema de monitorização das funções do núcleo do \testit{Linux}

%diminuição do número de trocas de contexto necessárias monitorização dinâmica das chamadas ao sistema efectuadas pelos processos e consequente filtragem dos pacotes de rede pertencentes a este de forma a apenas serem capturados os pacotes interessantes fazendo assim reduzir o nº de pacotes copiados e transferidos para a aplicação monitorizadora. Com a redução de transferencias do nº de pacotes reduz-se o nº de trocas de contexto, consequentemente reduz-se o impacto negativo da monitorização.

\keywords{PCap; Linux Kernel; Monitorização, KProbes}
\end{abstract}

\section{Introdução}
\label{sec:introduction}

A monitorização permite que diferentes partes de um programa ou processo possam ser analisados. Podemos analisar os tempos de execução de terminadas funções ou todo o processo, é possível analisar as interacções que se fazem com o exterior bem como outros parâmetros tais como a percentagem de utilização do(s) cpu(s) ou a utilização de memória.

A monitorização causa perdas no desempenho e por isso é desejável que seja o menor possível. Estas devem-se a que pelo simples facto de se executar uma observação, não existir trabalho útil para o processo.

\section{Monitorização}
\label{sec:mon_intro}

%apenas os conceitos base
%3/4 parágrafos

Na monitorização das interacções com o exterior via interfaces de rede é possível verificar que os principais causas da redução de desempenho são as frequentes trocas de contexto, as diferentes cópias de dados.
\td{FALTA DIFERNTES FORMAS DE MONITORIZACAO}

A instrumentação do código pode ser efectuada de forma estática ou dinâmica. Na instrumentação estática é necessário ter acesso ao código fonte, passar pelo ciclo colocação dos pontos a analisar, compilar, executar e novamente colocação dos pontos a analisar. Desta forma não é possível modificar os pontos de instrumentação nem interagir com estes. Na instrumentação dinâmica é possível efectuar sem acesso ao código fonte, permite a colocação e remoção de pontos de instrumentação, bem como interagir com o sistema de monitorização.

A monitorização em nível utilizador pode ser efectuada de diferentes formas. A instrumentação estática do código pode ser efectuada utilizando a biblioteca \textit{Gnu Profiller}. A instrumentação dinâmica pode ser efectuada utilizando diferentes técnicas, tais como:

Alteração da variável de ambiente \textit{LD\_PRELOAD} de forma a executar previamente uma biblioteca dinâmica que poderá modificar o comportamento do processo. Esta técnica implica que exista um conhecimento prévio sobre os cabeçalhos das funções que se queiram analisar. Para aplicações executadas em modo supervisor (\textit{root}) este método não funciona.

Executar o processo a ser monitorizado através do controlo do processo monitorizador. O processo monitorizador executa a chamada ao sistema exec ou seus derivados e indica ao núcleo de operação que esse processo irá ser monitorizado através da chamada ao sistema \textit{PTrace}. Esta é a forma como as ferramentas \textit{strace} e  \textit{GDB} actuam.


\subsection{Monitorização de rede}
\label{sub:mon_network__with_dynamic_filters_linux}
\td{explicar um pouco mais sobre a monitorização de rede no linux ...como é que acontece}

Como anteriormente foi indicado a monitorização de sistemas produz uma perda de desempenho no sistema. Quando se trata de monitorizar processos dinâmicos esta monitorização pode aumentar ainda mais esta perda. O sistema desenvolvido permite que seja monitorizado um processo que faça utilização das chamadas ao sistema sobre a pilha de protocolos TCP/IP.


\subsubsection{Utilização de filtros, diminuição de pacotes}
\label{subsub:socket_filter}

Uma forma de diminuir o número de pacotes copidados da interface para a aplicação monitorizadora é aplicar filtro(s) para apenas capturar os pacotes que realmente interessam. Estes filtros são aplicados através de uma maquina virtual de execução de filtros. Através da biblioteca \textit{LibPCap} é também possível aplicar filtros. Nesta biblioteca existe um sistema de optimização e aplicação de filtros bem como uma linguagem propria para os descrever e compilar para o sistema de filtros conhecido como \textit{BPF}. No núcleo do \textit{Linux} é reconhecido na máquina virtual de filtros uma versão um pouco diferente do \textit{BPF}, o \textit{LSF} (\textit{Linux Socket Filter}).
\td{Em algum ponto falta indicar que existe uma nova maquina virtual, que é baseada em just in time, mas que só funciona para x86\_64 devido ao número de registos ser maior face ao x86}


\td{FALTA Descrever como se processa a captura no nível mais baixo, junto ao driver ...}

\section{Desenho e arquitectura}
\label{sec:architecture}

Este sistema foi criado a pensar na modularidade e nas potêncialidades de modificação das diferentes componentes de forma a poder ser modificado, originando possibilidade de aumento de funcionalidades e diferentes desempenhos.

As quatro partes essenciais do sistema são: função de filtragem (ligação a um \textit{hook} ), monitorização das chamadas ao sistema, ou outras funções que estejam no sistema de rede, o repositório de dados e caso seja necessário o sistema de informação de análise da monitorização.

\subsection*{Instrumentação das chamadas ao sistema de rede}
\label{sub:mon_syscalls}

Para conseguir detectar todas as interacções que um processo executa com o exterior foi necessário monitorizar as chamadas ao sistema de rede de forma a garantir que todas estas interacções são detectadas. Uma forma de minimizar as trocas de contexto foi efectuar toda a monitorização dentro do kernel. Utilizando o sistema de monitorização KProbes, pertencente ao núcleo do Linux foi possível efectuar esta monitorização. Foram monitorizadas as chamadas ao sistema (\textit{sendto}, \textit{recvfrom}, \textit{bind}, \textit{accept}, \textit{connect} e  \textit{close}).
Apesar de se filtrar qual o processo que está a executar a chamada ao sistema verificou-se que a chamada ao sistema \textit{close} por ser utilizada intensivamente por todo o sistema de ficheiros que poderia ser um ponto onde este sistema iria ter pior desempenho. Por esta razão decidiu-se aplicar a monitorização à função \textit{sock\_close} a monitorização ao invés de ser na função mais genérica \textit{close} e assim permitia que apenas os processos que fizessem uso do sistema de transferência de dados utilizando os métodos de rede. Desta forma foi possível reduzir significativamente o número de eventos de monitorização da chamada ao sistema \textit{close}.

\subsection*{Filtro de pacotes}
\label{sub:packet_filter}

Este sistema de filtros dinâmicos permite que sejam efectuadas monitorizações de rede com e sem o sistema de filtragem de pacotes definidos no \textit{Linux Socket Filter}. De forma a alterar o menos possível a forma como é efectuado a monitorização de rede no Linux, foi colocar um \textit{hook} no sistema de rede. Este \textit{hook} serve para que quando esteja ligado, a monitorização passe pelo sistema dinâmico de filtragem permitindo assim efectuar a nova monitorização sem que se perca os beneficios do \textit{Linux Socket Filter}, pois esta é uma linguagem genérica que permite efectuar alguma análise aos pacotes que estão a ser monitorizados.


\subsection*{Repositório de dados}
\label{sub:data_repository}

Os portos \textit{TCP} ou \textit{UDP} que estão em utilização por um processo necessitam ser guardados num repositório de dados de forma a que quando um pacote chegar à interface de rede, possa ser comparado. 
A estrutura de dados escolhida para este repositório de dados foi uma àrvore \textit{Red and Black}. Como se trata de uma àrvore balanceada é possível obter um bom compromisso de tempo de acesso \textit{versus} quantidade de memória utilizada.

Em cada folha da àrvore existe uma estrutura 

\subsection*{Informação de análise}
\label{sub:data_information}

\section{Avaliação}
\label{sec:evaluation}

Escrever as tabelas actuais ... e verificar quais os dados necessários para outros testes ...
\paragraph*{}

\begin{table}
\caption{Envio de 1GB de dados por ftp}
\begin{tabular}{| c | c | c |}
\hline
\hspace {1cm} Aplicação \hspace {1cm} & Aplicação e TcpDump & Aplicação e TcpDump com módulo \\
\hline
91.8231 & 91.8653 & 92.1157 \\
\hline
\end{tabular}
\end{table}

\begin{center}
\begin{table}
\caption{Envio de 1GB de dados por http}
\begin{tabular}{ | c | c | c  | }
\hline
\hspace {1cm} Aplicação \hspace {1cm} & Aplicação e TcpDump & Aplicação e TcpDump com módulo \\
\hline
91.6948 & 91.6837 & 91.9228 \\
\hline
\end{tabular}
\end{table}
\end{center}

\section{Trabalho Relacionado}
\label{sec:related_work}
Trabalhos anteriores tentaram resolver os mesmos problemas mas continuavam a ter número de trocas de contexto.

Um dos trabalhos efectuado por Nuno Farruca~\cite{Farruca:2009}, monitorizou os processos por duas vias. Monitorizar o processo através da criação de uma biblioteca que mapeia as funções da biblioteca de C \textit{LibC} e modificando a variável LD\_PRELOAD, de forma a que quando fosse efectuada uma função da biblioteca de C que estivesse mapeada na biblioteca desenvolvida, estas fosse chamada primeiro de forma a obter os parâmetros das funções e assim comunicar à \textit{LibPCap} se os pacotes pertencentes a um determinado porto de um endereço são ou não para capturar. Uma outra forma foi obter os dados dos sockets pertencentes ao processo através do sistema de ficheiros virtual \textit{ProcFs} e executar a filtragem também em nível utilizador dos pacotes que chegam à interface capturadas através da \textit{LibPcap}.

O trabalho efectuado por \cite{1688981}, efectuou uma monitorização, utilizando o sistema de monitorização \textit{KProbes}, das funções de transmissão e recepção de dados dentro do núcleo do sistema. Desta forma é possível monitorizar os dados de um processo. Os dados recolhidos são analisados com o intuito de perceber se determinada porta e endereço são conhecidos e caso não sejam é adicionada a informação a uma tabela de dispersão utilizada para efectuar um novo filtro. O pacote capturado  é atrasado e re-injectado e forma a poder ser capturado pela biblioteca \textit{LibPCap} através do novo filtro.

\section{Conclusões}
\label{sec:conclusions}


\bibliographystyle{plain}
\bibliography{references}

\end{document}
