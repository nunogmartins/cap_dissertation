%%%%%%%%%%%%%%%%%%%%%%% file typeinst.tex %%%%%%%%%%%%%%%%%%%%%%%%%
%
% This is the LaTeX source for the instructions to authors using
% the LaTeX document class 'llncs.cls' for contributions to
% the Lecture Notes in Computer Sciences series.
% http://www.springer.com/lncs       Springer Heidelberg 2006/05/04
%
% It may be used as a template for your own input - copy it
% to a new file with a new name and use it as the basis
% for your article.
%
% NB: the document class 'llncs' has its own and detailed documentation, see
% ftp://ftp.springer.de/data/pubftp/pub/tex/latex/llncs/latex2e/llncsdoc.pdf
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\documentclass[runningheads,a4paper]{llncs}
\documentclass[a4paper]{llncs}

%\usepackage{amssymb}
%\setcounter{tocdepth}{3}
%\usepackage{graphicx}
\usepackage{url}
\usepackage[utf8]{inputenc}
\usepackage{todonotes}
%\usepackage{hyperref}
%\usepackage{booktabs}
%\usepackage{subfig}
%\usepackage{array}
\usepackage[portuges]{babel}

% \newcommand{\papertitle}{A Distributed Computing Framework for Heterogeneous Environments}


\newcommand{\papertitle}{PCap com filtragem orientada ao processo}

%\newcommand{\papertitle}{Leveraging GPUs for Scientific Computing}

%\hypersetup{pdfborder=0 0 0,
%            pdfauthor={Nuno Martins \and Vítor Duarte},
%%            pdfcreator=,
%            pdfkeywords={Pcap, linux, monitorização,},
%%            pdfsubject=TesteSubject,
%            pdftitle={\papertitle}
%           }


\urldef{\mailsa}\path|nuno.m.g.martins@gmail.com|
\urldef{\mailsb}\path|vad@di.fct.unl.pt|    

\newcommand{\keywords}[1]{\par\addvspace\baselineskip
\noindent\keywordname\enspace\ignorespaces#1}

\newcommand{\td}[1]{\todo[inline]{#1}}


\begin{document}

\mainmatter  % start of an individual contribution

% first the title is needed
\title{\papertitle}

\author{Nuno Martins\inst{1} e Vítor Duarte\inst{2}}
%
\authorrunning{\papertitle}
% (feature abused for this document to repeat the title also on left hand pages)

% the affiliations are given next; don't give your e-mail address
% unless you accept that it will be published
\institute{\email{nuno.m.g.martins@gmail.com} \and \email{vad@di.fct.unl.pt}\\
CITI --- Departamento de Informática,\\
Faculdade de Ciências e Tecnologia,\\
Universidade Nova de Lisboa, Portugal}
%\mailsa \qquad \mailsb}

%
% NB: a more complex sample for affiliations and the mapping to the
% corresponding authors can be found in the file "llncs.dem"
% (search for the string "\mainmatter" where a contribution starts).
% "llncs.dem" accompanies the docume\label{•} nt class "llncs.cls".
%

%\toctitle{Lecture Notes in Computer Science}
%\tocauthor{Authors' Instructions}
\maketitle

\begin{abstract}

A monitorização do comportamento dos processos é uma das melhores formas de compreender, detectar erros e avaliar o seu desempenho durante a sua execução real, ainda mais se não for possível aceder ao seu código fonte.
No entanto, o impacto no desempenho e comportamento pode ser bastante significativo. O caso das interacções via rede não é excepção, sendo o PCap um dos sistemas mais populares para monitorizar/capturar o tráfego de rede ao nível do SO. Este trabalho baseia-se nesse sistema e no suporte dado pelo núcleo Linux, para permitir capturar as interacções via rede de processos específicos, procurando também limitar o impacto negativo desta monitorização.
Pretende-se que sem conhecer \emph{à priori} quais os portos que irão ser utilizados pelo processo, e sem necessitar de capturar todo o tráfego que circula pela rede obter apenas os pacotes referentes ao processo alvo. 
  Para tal, foi criada uma forma de filtragem no \emph{bpf-filters}, usados pelo pcap que, dinamicamente, através da monitorização das chamadas ao sistema do processo, permite manter os endereços e portos em utilização pelo processo alvo e capturar apenas o seu tráfego. Deste modo é possível obter apenas os dados relevantes, diminuir o volume de dados transferidos entre o núcleo de sistema e a ferramenta que monitoriza/analisa o processo, assim como um menor número de trocas de contexto, com vantagens funcionais e de desempenho. 

\keywords{Instrumentação, KProbes, Linux Kernel, Monitorização, Núcleo do Linux, PCap}
\end{abstract}

\section{Introdução}
\label{sec:introduction}

A monitorização permite que diferentes partes de um programa ou processo possam ser analisados. Podemos analisar os tempos de execução de terminadas funções ou todo o processo, é possível analisar as interacções que se fazem com o exterior bem como outros parâmetros tais como a percentagem de utilização do(s) cpu(s) ou a utilização de memória.

A monitorização causa perdas no desempenho e por isso é desejável que seja o menor possível. Estas devem-se a que pelo simples facto de se executar uma observação, não existir trabalho útil para o processo.

\section{Monitorização}
\label{sec:mon_intro}

%apenas os conceitos base
%3/4 parágrafos

Na monitorização das interacções com o exterior via interfaces de rede é possível verificar que os principais causas da redução de desempenho são as frequentes trocas de contexto, as diferentes cópias de dados.
\td{FALTA DIFERENTES FORMAS DE MONITORIZACAO}


A instrumentação do código pode ser efectuada de forma estática ou dinâmica. Na instrumentação estática é necessário ter acesso ao código fonte, passar pelo ciclo colocação dos pontos a analisar, compilar, executar e novamente colocação dos pontos a analisar. Desta forma não é possível modificar os pontos de instrumentação nem interagir com estes. Na instrumentação dinâmica é possível efectuar sem acesso ao código fonte, permite a colocação e remoção de pontos de instrumentação, bem como interagir com o sistema de monitorização.

\subsection{Monitorização de aplicações}
\label{sub:user_level_monitor}

A monitorização em nível utilizador pode ser efectuada de diferentes formas. A instrumentação estática do código pode ser efectuada utilizando a biblioteca \textit{Gnu Profiller}. A instrumentação dinâmica pode ser efectuada utilizando diferentes técnicas, tais como:

Alteração da variável de ambiente \textit{LD\_PRELOAD} de forma a executar previamente uma biblioteca dinâmica que poderá modificar o comportamento do processo. Esta técnica implica que exista um conhecimento prévio sobre os cabeçalhos das funções que se queiram analisar. Para aplicações executadas em modo supervisor (\textit{root}) este método não funciona.

Executar o processo a ser monitorizado através do controlo do processo monitorizador. O processo monitorizador executa a chamada ao sistema exec ou seus derivados e indica ao núcleo de operação que esse processo irá ser monitorizado através da chamada ao sistema \textit{PTrace}~\cite{PTrace}. Esta é a forma como as ferramentas \textit{strace}~\cite{strace} e  \textit{GDB}~\cite{gdb} actuam. Como é visível é necessário um suporte do SO para que se possa proceder a uma monitorização eficiente e correcta.
\td{falta falar do sysprof tb tem de levar suporte do núcleo}

\subsection{Monitorização do núcleo}
\label{sub_kernel_instrumentation}

A monitorização do núcleo do \textit{Linux} não é efectuado da mesma forma das aplicações em nível utilizador. Existem diferentes sistemas de monitorização e instrumentação do núcleo, alguns pertencem à versão principal do núcleo do \textit{Linux} outros são adicionados aplicando algumas correcções/patches. Dentro do núcleo existem sistemas de instrumentação dinâmica e estática. Um dos sistemas de instrumentação estática do código é o \textit{TracePoints}, este sistema permite que sejam colocadas funções que irão ser executadas em certos pontos do código. Este sistema permite que se estes pontos não estejam activos apenas um pequeno custo (de verificação se está activo) seja imposto. Em oposição aos sistemas estáticos existem os sistemas dinâmicos, que podem ser adicionados e removidos em tempo de execução. Estes sistemas podem ser distinguidos em dois tipos, os que permite efectuar um traço da computação e aqueles que utilizam amostragens em determinados intervalos definidos. Deste último existe o OProfile~\cite{qq_coisa}. \td{Dizer qq coisa sobre OProfile}


Dentro da categoria dos sistemas que efectuam um traço de execução existe o \textit{LTT}~\cite{ltt} (mais recentemente o \textit{LTTng}~\cite{lttng}), o \textit{KProbes} ~\cite{KProbesSite,kernel_debug_printk_on_fly}

Um sistema de instrumentação do núcleo do \textit{Linux} é o \textit{KProbes}. Este sistema permite colocar código de instrumentação do núcleo através da definição de um módulo. Existem três formas de monitorização utilizando o \textit{KProbes}, sendo o \textit{KProbe} a generalização e o \textit{JPrtobe} e \textit{KRetProbe} particularizações.

O \textit{KProbes} permite que sejam instrumentados as funções do núcleo bem como de módulos carregados no sistema. Este sistema tem uma forma bem definida de criação e destruição dos pontos de instrumentação e permite ao programador um maior controlo. Como programar para o núcleo do \textit{Linux} pode ser complicado foram criadas pelo menos duas ferramentas (\textit{SystemTap} ~\cite{systemtap} e \textit{DProbes} ~\cite{dprobes}) que garantem algumas facilidade de programação, segurança, portabilidade entre versões, entre outras. Os programadores utilizando as linguagens fornecidas por estes programas criam os seus programas e as aplicações geram um módulo do núcleo, onde permite os acessos às funções instrumentadas.

\subsubsection{Monitorização de rede}
\label{subsub:mon_network__with_dynamic_filters_linux}

A monitorização tráfego de rede é efectuado de forma passiva. A aplicação monitorizadora indica que quer recolher todo o tráfego, ou apenas um subconjunto deste, permitindo assim díminuir o número de pacotes a capturar. Consequentemente diminui o número de cópias de dados e trocas de contexto entre o núcleo e a aplicação.
\td{explicar um pouco mais sobre a monitorização de rede no linux ...como se processa}


Como anteriormente foi indicado a monitorização de sistemas introduz perdas no desempenho do sistema. Quando se trata de monitorizar processos dinâmicos esta monitorização pode aumentar ainda mais esta perda. O sistema desenvolvido permite que seja monitorizado um processo que faça utilização das chamadas ao sistema sobre a pilha de protocolos TCP/IP.

\paragraph{Firewall}

Existe um sistema de \textit{firewall} no \textit{Linux}, que gere o fluxo de dados de e para o exterior através de politicas de controlo. Este sistema é o \textit{NetFilter} e está dentro do núcleo do \textit{Linux}. A gestão do fluxo de dados é efectuada através de regras, estas podem ser indicadas em qualquer momento ao \textit{NetFilter} para poderem ser aplicadas. Estas regras são baseadas na definição do tráfego, ou seja, se é de entrada ou de saída ou de redireccionamento, entre outros parâmetros tais como portas e interfaces de rede.

O \textit{NetFilter} é composto por vários módulos do núcleo, um deles é o \textit{conntrack}. Este módulo permite monitorizar os pacotes pertencentes a um fluxo, assemelhando-se assim a uma \textit{firewall} com estado. Uma das desvantagens destes sistemas é a necessitade de conhecer as especificações do protocolo e de não mapear um fluxo de dados em relação a um processo.

\subsubsection*{Suporte de Monitorização de rede}
Em 1992 foi desenvolvido o \textit{Berckeley Packet Filter (BPF)}~\cite{Mccanne92thebsd} um sistema de filtragem de pacotes efectuado através de uma máquina de virtual de registos. O \textit{Linux} apresenta uma versão semelhante ao \textit{BPF} com o nome \textit{Linux Socket Filter}. Neste sistema os filtros são definidos numa linguagem que contem instruções para efectuar movimentações de dados de e para alguns registos e para calculos lógicos sobre os dados dos pacotes \textit{TCP/IP}. Cada programa a ser executado pode ser uma combinação de diferentes regras. Cada pacote que é recebido ou transferido na interface de rede é aplicado o filtro anteriormente definido. Se for aceite é então efectuado uma cópia do pacote para um repositório em anel que posteriormente irá ser consumido pela aplicação monitorizadora.

\paragraph{Utilização de filtros, diminuição de pacotes}
\label{subsub:socket_filter}

Uma forma de diminuir o número de pacotes copiados da interface para a aplicação monitorizadora é aplicar filtro(s) para apenas capturar os pacotes que realmente interessam. Estes filtros são aplicados através de uma maquina virtual de execução de filtros. Através da biblioteca \textit{LibPCap} é também possível aplicar filtros. Nesta biblioteca existe um sistema de optimização e aplicação de filtros bem como uma linguagem propria para os descrever e compilar para o sistema de filtros conhecido como \textit{BPF}. No núcleo do \textit{Linux} é reconhecido na máquina virtual de filtros uma versão um pouco diferente do \textit{BPF}, o \textit{LSF} (\textit{Linux Socket Filter}).
\td{Em algum ponto falta indicar que existe uma nova maquina virtual, que é baseada em just in time, mas que só funciona para x86\_64 devido ao número de registos ser maior face ao x86}


\td{FALTA Descrever como se processa a captura no nível mais baixo, junto ao driver ...}


O tamanho do anel de blocos é definido ao inicio da monitorização e cada pacote que seja para capturar é colocado em um bloco. Como os blocos são de tamanho fixo e os pacotes de tamanho variável existe um desperdício de espaço para dados, uma vez que não existe um ajuste ao tamanho do pacote.




\section{Desenho e arquitectura}
\label{sec:architecture}

O sistema proposto foi desenvolvido tendo em conta a modularidade e as potencialidades de modificação de diferentes componentes, de modo a torná-lo extensível, possibilitando o aumento de funcionalidades e obter diferentes desempenhos. Para tal, o sistema criado está dividido em 4 componentes principais: função de filtragem (que recorre à ligação de um \textit{hook}), uma componente de instrumentação das chamadas ao sistema (ou outras funções contidas no sistema de rede), um repositório de dados e, finalmente, caso seja necessário, a utilização de um sistema de informação de análise da monitorização.

Este sistema permite que sejam capturados os pacotes de rede de um processo, sem que exista um conhecimento prévio sobre o(s) protocolo(s) em utilização. A utilização de um sistema de instrumentação do núcleo foi necessário de forma perceber qual o processo que executou a chamada ao sistema, permitindo desta forma obter apenas as chamadas ao sistema do(s) processo(s) que realmente são monitorizados. De forma a minimizar as trocas de contexto, todo o sistema foi desenvolvido dentro do núcleo do \textit{Linux}, assim apenas as outras aplicações de façam uso da biblioteca \textit{LibPcap}, do programa \textit{TcpDump} ou suas variantes tenham de executar código em nível utilizador. Foi construído um sistema que permite facilmente modificar os seus componentes, mas que no entanto não irá sacrificar o desempenho, por isso deverá ser minimalista nas suas opções.

A apresentação da estrutura do sistema é apresentada em seguida, bem como uma imagem com os constituíntes do deste.

\subsection*{Instrumentação das chamadas ao sistema de rede}
\label{sub:mon_syscalls}

Um ponto importante deste sistema, constituiu na garantia que todas as interacções desencadeadas por um processo com o exterior fossem detectadas. Para tal, foi necessário recorrer à monitorização das chamadas ao sistema de rede, ou seja, realizar a monitorização ao nível do Kernel, permitindo, assim, minimizar as trocas de contexto. Tirando partido da utilização do sistema de monitorização KProbes (pertencente ao núcleo do Linux), foi possível realizar a monitorização sob um pequeno conjunto de chamadas ao sistema, nomeadamente: sendto, recvfrom, bind, accept, connect e close. Embora o processo que está a executar a chamada ao sistema esteja a ser filtrado, verificou-se que aquando da chamada ao sistema close, ao ser utilizada intensivamente por todo o sistema de ficheiros, esta poderia constituir num ponto onde o sistema iria obter pior desempenho. Desta forma, decidiu-se aplicar a monitorização à função sock\_close, garantindo apenas que os processos que fizessem uso do sistema de transferência de dados, utilizando os métodos da rede, fossem utilizados. Deste modo, foi possível reduzir significativamente o número de eventos de monitorização da chamada ao sistema close.

\subsection*{Filtro de pacotes}
\label{sub:packet_filter}

A função de filtragem aplicado a este sistema assenta no uso de filtros dinâmicos, aos quais permitem efectuar monitorização de rede com ou sem o sistema de filtragem de pacotes
definidos no Linux Socket Filter. Deste modo, para minimizar as alterações ao nível da monitorização de rede no Linux, introduziu-se um hook no sistema de rede. Através da utilização deste hook permite que, quando ligado, a monitorização passe pelo sistema dinâmico de filtragem, possibilitando efectuar uma nova monitorização e tirar partido dos benefícios da utilização do Linux Socket Filter (na medida em que se trata de uma linguagem genérica, permitindo efectuar uma análise sobre os pacotes que estão a ser monitorizados).

\subsection*{Repositório de dados}
\label{sub:data_repository}

Os portos TCP e UDP em utilização por um dado processo necessitam ser guardados num repositório de dados, de forma que aquando da chegada de um pacote à interface de rede, este possa ser comparado \td{explicação um pouco mais detalhada}. A estrutura dados escolhida para o efeito, para produzir o repositório pretendido, corresponde a uma árvore \textit{Red and Black}. O uso deste tipo de estrutura permite que o conteúdo da árvore esteja balanceado/equilibrado, obtendo-se um bom compromisso de tempo de acesso à estrutura \textit{versus} quantidade de memória utilizada.

\subsection*{Informação de análise}
\label{sub:data_information}

De forma a poder indicar qual o processo que se deseja monitorizar foram criados três ficheiros. Estes foram criados no sistema de ficheiros virtual \textit{DebugFs}~\cite{DebugFs}.

\subsection{Aplicação Monitorizadora}
\label{sub:monitor_app}
Para poder efectuar os testes de avaliação foi criado uma aplicação em nível utilizador para poder lançar sob seu controlo a aplicação a ser monitorizada.

\section{Avaliação}
\label{sec:evaluation}
Este sistema foi avaliado funcionalmente através dos protocolos em \textit{ftp} e \textit{http}. Estes testes iniciais não visaram a performance mas sim a correcção de todos os pacotes envolvidos nas comunicações.
O sitema de testes utilizados permitiu que fossem capturados os pacotes de uma transferência de um ficheiro de um servidor \textit{ftp} e um servidor de \textit{http}, os dados foram capturados na obtenção do ficheiro (cliente).

Escrever as tabelas actuais ... e verificar quais os dados necessários para outros testes ...
\paragraph*{}

\begin{table}
\caption{Envio de 1GB de dados por ftp}
\begin{tabular}{| c | c | c |}
\hline
\hspace {1cm} Aplicação \hspace {1cm} & Aplicação e TcpDump & Aplicação e TcpDump com módulo \\
\hline
91.8231 & 91.8653 & 92.1157 \\
\hline
\end{tabular}
\end{table}

\begin{center}
\begin{table}
\caption{Envio de 1GB de dados por http}
\begin{tabular}{ | c | c | c  | }
\hline
\hspace {1cm} Aplicação \hspace {1cm} & Aplicação e TcpDump & Aplicação e TcpDump com módulo \\
\hline
91.6948 & 91.6837 & 91.9228 \\
\hline
\end{tabular}
\end{table}
\end{center}

\section{Trabalho Relacionado}
\label{sec:related_work}
Trabalhos anteriores tentaram resolver os mesmos problemas mas continuavam a ter número de trocas de contexto.

Um dos trabalhos efectuado por Nuno Farruca~\cite{Farruca:2009,duarte10}, monitorizou os processos por duas vias. Monitorizar o processo através da criação de uma biblioteca que mapeia as funções da biblioteca de C \textit{LibC} e modificando a variável LD\_PRELOAD, de forma a que quando fosse efectuada uma função da biblioteca de C que estivesse mapeada na biblioteca desenvolvida, estas fosse chamada primeiro de forma a obter os parâmetros das funções e assim comunicar à \textit{LibPCap} se os pacotes pertencentes a um determinado porto de um endereço são ou não para capturar. Uma outra forma foi obter os dados dos sockets pertencentes ao processo através do sistema de ficheiros virtual \textit{ProcFs} e executar a filtragem também em nível utilizador dos pacotes que chegam à interface capturadas através da \textit{LibPcap}.

O trabalho~\cite{1688981} com o título \textit{Application-specific packet capturing using kernel probes}, efectuou uma monitorização, utilizando o sistema de instrumentação \textit{KProbes}, das funções de transmissão e recepção de dados dentro do núcleo do sistema. Desta forma é possível monitorizar os dados de um processo. Os dados recolhidos são analisados com o intuito de perceber se determinada porta e endereço são conhecidos e caso não sejam é adicionada a informação a uma tabela de dispersão utilizada para efectuar um novo filtro. O pacote capturado  é atrasado e re-injectado e forma a poder ser capturado pela biblioteca \textit{LibPCap} através do novo filtro.

\section{Conclusões}
\label{sec:conclusions}


\bibliographystyle{plain}
\bibliography{references}

\end{document}
