\chapter{Implementação da solução proposta}
\label{cap:Implementacao}

% falta falar sobre filesystem vfs e como chegar ao socket file private\_data para alem da parte de interrupts, tasklets e bottomhalfs bem como sobre os contextos de execucao
Falta falar sobre os motivos e a estrutura desejada para esta implementação

\section{MRoP e a sua implementação}
\label{sec:mrop_implementation}

A implementação da solução MRoP teve em consideração o desenvolvimento de código minimalista, a reduzida alteração do código do núcleo, e a utilização de \textit{APIs} internas.
É opaco à implementação da biblioteca \textit{PCap}, e pode ser integrado nesta.
A implementação é autocontida num módulo do núcleo, para poder poder ser carregada e libertada do deste pelo administrador.
A modularização das diversas componentes, permite um desenvolvimento de cada subcomponente de forma autónoma.

No capítulo \ref{} foram apresentados, a título exemplificativo, alguns sistemas que permitem efectuar monitorização ou filtragem de pacotes com indicação de um processo.
No MRoP, apesar de utilizar o sistema de instrumentação do núcleo \textit{KProbes}, diferencia-se das soluções apresentadas, por se encontrar totalmente implementado no núcleo, com reduzida utilização de memória e perturbação do sistema.

Como apresentado na secção \ref{}, o sistema de monitorização de rede é utilizado para cada pacote que circula na rede.

\begin{figure}[ht]
\centering
\includegraphics[scale=0.5]{arquitectura.pdf}
\caption{Arquitectura geral}
\label{fig:general_architecture}
\end{figure}





%Por cada pacote ter de atravessar toda a arquitectura de rede incluida no \textit{vfs} seria demasiado pesado para o sistema.

%------- apresentar as diversas seccoes ao leitor ----------------

Nas subsecções seguintes irão ser apresentados os quatro subcomponentes do MRoP como se apresentada na figura \ref{fig:general_architecture}.


\section{Estado dos \textit{sockets}}

Para manter a informação sobre os endereços e portos que uma aplicação está a utilizar, sem que seja necessário consultar os canais de rede, foi necessário criar um repositório de dados que contivesse informações relevantes para as decisões do filtro de captura.
Neste repositório existe a necessidades de ter funções de inserção, remoção e consulta, sendo que qualquer uma destas deverá ser efectuada com celeridade procurando estruturas que tenham uma complexidade temporal \textit{BigO}, O(1) ou O(log n).

As estruturas de dados com suporte no núcleo que permitem a criação de um repositório de dados são:

%\subsection{Com suporte no núcleo}
%outro titulo alternativas disponíveis

\begin{description}

\item[BitMap]
%\subsubsection{Bitmap}

O recurso a um mapa de bits permitiria de um modo bastante rápido e com uma reduzida utilização de memória, conhecer se um determinado porto estaria em utilização por um determinado processo.
O núcleo tem suporte para tratamento de mapas de bits, ou seja, verifica se um determinado bit num conjunto de memória está ou não activo, e pode igualmente afectar um determinado bit num conjunto de memória.
Este processo apesar de extremamente rápido, carece de modularidade na utilização de multiplos endereços de rede, pois apenas controla os portos, não dispondo de suporte para protocolos ou multiplos endereços de rede.
 
Uma solução seria agrupar os diferentes mapas de bits sob a terminologia de um endereço, mas e se fosse udp ou tcp ?
E quando um processo efectua um bind sob todas as interfaces do sistema ? 
E quando é utilizada mais uma interface virtual sob uma real ? .....


\item[Listas]

No núcleo existe uma implementação bastante eficiente da estrutura de dados \emph{lista} (\emph{list}), contendo apenas dois apontadores, destinando-se um ao elemento que o precede e outro para o seguinte.

Apesar de não ser necessário definir uma lista com o máximo número de portos, porquanto estes podem ser adicionados dinamicamente, a complexidade temporal de pesquisa no pior caso é de O(n), não podendo ser reconhecida como bom indicador de desempenho para este estudo.
No entanto quando o número de elementos não é elevado, a utilização de uma lista apresenta-se como uma boa solução.

%\subsubsection{Listas duplamente ligadas}
%\subsubsection{Árvores}

\item[Árvores Binária]
Apesar de não ser necessário percorrer os elementos ou obter os indíces de forma ordenada. 

%\paragraph{Arvores Balanceadas}
\item[Árvore Balanceada]
\textit{Red-black Tree} 

No núcleo existe uma implementação parcial de uma árvore \textit{Red-black} genérica, que permite o acesso aos dados através de chave, ou seja é uma estrutura associativa.\ref{}
A árvore \textit{Red-black} é semi-balanceada, ou seja, a diferença de alturas entre o ramo mais profundo e o mais curto é de apenas 1.
Esta propriedade é mantida através de rebalanceamentos da árvore em inserções e remoções, o que provoca um custo na sua utilização, mas como no caso esperado existem mais consultas do que inserções e remoções, este custo é amortizado.
Para utilizar esta estrutura de dados é necessário definir três funções (inserção, remoção e consulta) de manipulação da árvore.
O suporte fornecido pelo núcleo apenas permite manusear a árvore, sendo necessário definir as funções que utilizam a chave de acesso ao conteudo dos dados, que pela sua especificidade, não foram incluídas no suporte.

De referir igualmente, que para o objecto deste estudo o número do porto dos protocolos (\textit{tcp} e \textit{udp}), é considerada a chave mais adequada.
Considerando o número máximo de porto possíveis nos protocolos (\textit{TCP} e \textit{UDP}), a árvore terá de conter 65535 elementos, e a sua altura será de 16, ou seja para pesquisar um dos elementos nos extremos, máximo ou mínimo, serão necessárias efectuar 16 iteraçoes sobre ela.
Apesar de não constituir um requisito, é possível obter de forma ordenada todas as chaves, bem como os valores que lhe estão associados.

-----------------------------------------------------------------------------------------------------------

Complexidade de inserção, pesquisa e remoção é O(log n), sendo n o número de elementos da árvore.

Pode existir uma penalização no desempenho, devido à necessidade de balancear a àrvore.
Os ganhos provenientes deste balanceamento, face às àrvores não balanceadas, permite manter a complexidade média de acesso aos dados em O(log(n)), ao invés de um possível decremento até O(n), ou seja a árvore degenerar em uma lista.

-----------------------------------------------------------------------------------------------------------

\item[Radix Tree]
talvez falar sobre esta arvore ....

\end{description}

\paragraph*{}
Outras estruturas de dados passiveis de serem consideradas, apesar de não possuirem suporte no núcleo.

\begin{description}
%\subsubsection{Tabela de dispersão}
\item[Tabela de Dispersão]
No núcleo existe uma implementação de tabelas de dispersão que efectuam a dispersão e o controlo sobre as suas chaves.


%\subsubsection{Bloom Filter}
\item[Bloom Filter]
bloom filters ...

\end{description}
\paragraph*{}
A opção pela estrutura de dados \textit{Red-black tree} deve-se principalmente ao desempenho e à existência de implementação da estrutura no núcleo do \textit{Linux}.

O ciclo de desenvolvimento do MRoP foi efectuado mais rapidamente tendo em consideração a confiança na validação da estrutura de dados \textit{Red-black tree}, uma vez que esta está em utilização no núcleo e tem sido extensivamente analisada ao longo dos anos.
 
\subsection{Estrutura utilizada}
\label{sub:repo_structure}

O repositório criado através de uma árvore \textit{Red and Black} contém vários elementos com uma estrutura bem definida, que contém obrigatoriamente um elemento \textit{rb\_node}, para possibilitar a manipulação da árvore e um elemento outro, comparativo, utilizado como chave.
Além dos já referidos esta estrutura contempla outros elementos que seguidamente se descrevem.

\begin{figure}[ht]
\begin{minipage}[b]{0.5\linewidth}
\centering
\includegraphics[scale=0.8]{portInfo_structure.pdf}
\caption{Elemento da árvore}
\label{fig:portInfo}
\end{minipage}
\hspace{0.5cm}
\begin{minipage}[b]{0.5\linewidth}
\centering
\includegraphics[scale=0.8]{local_address_list}
\caption{Lista de endereços}
\label{fig:local_address_list}
\end{minipage}
\end{figure}

A figura \ref{fig:portInfo} apresenta a disposição dos elementos da estrutura \textit{PortInfo}, sendo que as listas de endereços \textit{IP} das interfaces de rede, são adicionadas através da estrutura apresentada na figura \ref{fig:local_address_list}.
Os elementos do repositório, são instâncias da estrutura \textit{PortInfo}, adicionados através dos \textit{handlers} das funções instrumentadas em conformidade com a figura \ref{fig:repo_example}.

\begin{figure}[ht]
\centering
\includegraphics[scale=0.7]{repositorio_exemplo.pdf}
\caption{exemplo}
\label{fig:repo_example}
\end{figure}

\subsection{\textit{API} de comunicação interna do MRoP}
\label{sub:repo_api}

Com o objectivo de efectuar inserções, consultas e remoções dos dados do repositório, foi criada uma \textit{API} interna ao MRoP, que permite validar os parâmetros passados às funções do repositório de dados.
Através desta \textit{API} foi possível efectuar a separação das componentes MRoP o que contribuiu para introduzir beneficios na modularidade do código.

\begin{figure}[ht]
\centering
\includegraphics[scale=0.7]{API_connect_drawing.pdf}
\caption{API interna}
\label{fig:api_connect}
\end{figure}

Esta \textit{API} permite aos \textit{handlers} das funções instrumentadas, efectuar as operações de inserção e remoção sobre a componente \textit{Estado dos Sockets}.
A operação de consulta é particularmente importante para a filtragem de pacotes das interfaces de rede.

Não obstante reduzir o desempenho, devido à necessidade de chamar os métodos especificos ao repositório, permite a sua substituição, sem que se verifique a modificação do código.

Apesar dos processos monitorizados terem grande dinamismo nas comunicações, a maior percentagem de operações sobre o repositório concentra-se ao nível da consulta.
As restantes operações de inserção e remoção repartem entre si igual percentagem.
Assim, é esperado que para cada inserção exista uma remoção.
Após a monitorização de um processo é suposto que a componente \textit{Estado dos Sockets}, apresente um número de elementos igual ao que antecedeu a monitorização.

\section{Instrumentação de funções do núcleo}

%----------------------------------------------------------------------------------------------------------

%Como foi anteriormente descrito em \ref{subsection:network} sobre as chamadas aos sistema para utilizar as funcionalidades de rede

%Foi necessário conhecer a \textit{ABI}\ref{ABI}\cite{ABI} referente às arquitecturas suportadas, \textit{x86} e \textit{x86\_64}, para a passagem de parâmetros das chamadas aos sistema.

%O sistema de \textit{KProbes} permite consultar os registos do processador onde foi efectuada a chamada à função (neste caso a chamada ao sistema).
% Por isso foram definidos 6 \textit{KRetProbes} referentes às chamadas \textit{connect}, \textit{bind}, \textit{accept}, \textit{sendto}, \textit{recvfrom} e
%\textit{close}.
% Para esta última \textit{close} devido à elevada utilização desta chamada ao sistema por diferentes aplicações no sistema, foi utilizada a função \textit{qqq coisa ...  ????}

%Para efectuar a monitorização das interacções de rede de um processo foi necessário recorrer à instrumentação de funções do núcleo.

%Através da instrumentação de funções do núcleo foi possível manter o contexto da execução do processo.

%Como apresentado e concluído na secção \ref{}, o sistema de monitorização que melhor se adequa ao problema exposto é o \textit{KProbes}.
% Deste sistema utilizou-se o \textit{KRetProbe}, de forma a instrumentar a entrada e retorno de funções.
% Obter os parâmetros de entrada das funções, principalmente o \textit{file descriptor}, tornou-se essencial.
% Para garantir que o repositório do estado do processo está coerente com o estado do núcleo, foi necessário obter o valor de retorno das funções.
% Por estas razões e porque as chamadas ao sistema têm ciclos de modificação da bastante lentos, o que evidência elevada estabilidade e consistência do núcleo, e por ser ponto de entrada do processo no núcleo foram as funções instrumentadas.

%As subsecções \ref{} .... \ref{} apresentam as funções do núcleo que foram instrumentadas.

%
% faltam as subsecoes ... 
%

%----------------------------------------------------------------------------------------------------------

A metodologia aplicada à resolução do problema de desempenho, baseia-se no desenvolvimento de uma componente para efectuar uma análise aos canais de comunicação de rede, utilizados por um processo, que insira a informação necessária no repositório.
Logo que um pacote chega ao sistema de monitorização, este faz uso do repositório para decidir da sua captura.


De entre os sistemas analisados foi o \textit{KProbes}, que sendo dinâmico permite uma menor sobrecarga.
Os restantes continham componentes de \textit{logging} que para a realização deste estudo, apresentavam uma sobrecarga desnecessária, afectando negativamente o desempenho.

Para além do sistema de instrumentação utilizado foi igualmente considerado o número de funções a instrumentar.

Para além de se ter tido em consideração o sistema de instrumentação utilizado, foi também tido em consideração o número de funções a instrumentar.
A sobrecarga total exercida pela instrumentação de funções do núcleo, tem em conta não só o número de funções que são instrumentadas, como o número de vezes que estas são executadas.

O conhecimento adquirido com a análise efectuada no capítulo \ref{cap:Estrutura}, sobre a \textit{Arquitectura de rede em Linux}, afectou positivamente a opção sobre as funções a instrumentar.

O MRoP, foi desenvolvido para monitorizar a utilização de canais da familia \textit{inet}, tendo como particularidade a utilização de canais baseados nos protocolos \textit{tcp} e \textit{udp}, e instrumenta um reduzido número de funções do núcleo pertencentes ao subsistema de rede.

O \textit{tcp} e o \textit{udp} apresentam em comum algumas funções com protocolos de outras familias, principalmente quando são executadas chamadas ao sistema, onde o nível de abstracção sobre estes protocolos é elevado.
Com o objectivo de dimínuir o número de funções a instrumentar, decidiu-se pelas chamadas ao sistema, obtendo assim um maior nível de abstração e um controlo directo dos processos de nível utilizador.

As chamadas ao sistema instrumentadas foram: \textit{sendto}, \textit{recvfrom}, \textit{connect}, \textit{bind}, \textit{accept} e \textit{close}.
As análises inicialmente efectuadas demonstraram que apenas a chamada ao sistema \textit{close}, era demasiadas vezes executada, penalizando o desempenho global do sistema.
Esta situação radica no facto da chamada ao sistema \textit{close}, ser utilizada extensivamente para fechar canais, independentemente destes serem ficheiros, \textit{sockets}, \textit{pipes}, etc.
Para solucionar esta situação foi necessário encontrar a função uma função que lidasse exclusivamente com o fecho de \textit{sockets}, de modo a reduzir a sobrecarga imposta pela instrumentação.


\subsection{Filtro de processos}

%------------------------------------------------------------------------------------------------

%A filtragem dos processos que efectuam as chamadas ao sistema de rede impôs um novo desafio.
% Se apenas filtrar as chamadas de um processo/pid seria apenas verificar se o pid é igual ao que se pretende é trivial e com baixa sobrecarga.
% Para um utilizador que queria analisar um processo, e não saiba qual dos fluxos do processo é responsável pela comunicação de rede, tornou-se complicado.

%Com esta abordagem ainda existe a possibilidade de não se obter todas as \textit{task} do processo, caso este tenha um àrvore com mais de 3 níveis, mas a sobrecarga sobre o sistema é inferior à situação de monitorização da criação de processos no sistema.
% Estes três identificadores foram escolhidos pois permitem identificar até 3 níveis da árvore de um processo.

%Seria bom colocar uma imagem de uma àrvore de processo .... 

%Os identificadores têm de ser escritos para os ficheiros respectivos no \textit{DebugFs}, que serão explicados na secção \ref{}.

%-----------------------------------------------------------------------------------------------------

O \textit{KProbes} é um sistema de instrumentação do núcleo que não distingue entre que funções, não \textit{inline}, está a efectuar a instrumentação.
Não existindo suporte no \textit{KProbes} para filtrar o processo, que está a efectuar uma chamada ao sistema, foi necessário desenvolver uma metodologia que permitisse reduzir a sobrecarga, quando a monitorização é efectuada sobre um processo que não o desejado.

%-------------------------

%Os objectivos referidos principais continuam a ser reduzida sobrecarga e actualização permanente do(s) processo(s) a monitorizar.
%Tendo estas caracteristicas como base algumas possibilidades foram tidas em consideração, onde o principal desafio foi conseguir manter a informação actualizada.

%--------------------------------------

No intuito de sanear esta situação uma das possibilidades foi a criação de um repositório com a informação sobre os identificadores dos processos a monitorizar, para o que foi necessário uma vez mais uma estrutura de suporte a este repositório, bem como funcionalidades de adição, remoção, actualização e consulta.
Este repositório teria de conter a estrutura genealógica do processo a monitorizar, assim como um componente que actualiza-se esta informação.
A actualização desta estrutura poderia ser efectuada através da instrumentação da chamada ao sistema \textit{fork} ou \textit{clone}.
Sempre que fossem invocadas as funções já referidas, seria efectuada uma consulta ao repositório e a partir da informação obtida, este seria ou não, actualizado.
Esta possibilidade, ao contemplar a remoção de dados do repositório, necessitaria também de instrumentar a função de termino de processos.

Considerando que a actualização dinâmica deste repositório, sem alterar o código do núcleo, afectava negativamente o desempenho do sistema na sua totalidade, optou-se por abandonar esta alternativa em virtude da criação e destruição de processos poder ser elevada.


Face a esta situação optou-se por efectuar uma análise aos campos da estrutura, \textit{task\_struct}, o que permitiu compreender de que modo os identificadores dos processos se relacionam com os dos membros da árvore genealógica do processo.
Desta análise concluí-se que, os identificadores \textit{pid}, \textit{tid} e \textit{ppid} permitem na grande maioria das aplicações, identificar toda a árvore genealógica.


%\subsubsection{Identificadores}

%No núcleo do \textit{Linux} quando um processo é criado os identificadores, \textit{pid} e \textit{tgid} são iguais.

\section{Filtro de pacotes, extensão ao LSF}

No sistema de monitorização de rede, um dos componentes é uma função que serve de máquina virtual às instruções do \textit{LSF}.
Esta função itera sobre o filtro, executando instrução a instrução, sobre o pacote (recebido ou enviado), até encontrar uma instrução de retorno (\textit{BPF\_RET} ou \textit{BPF\_RET\_A}).
Consoante o valor retornado nestas instruções, o pacote analisado é ou não capturado.
Se for capturado, é efectuada uma cópia do pacote e colocado num \textit{ring buffer}, partilhado com a aplicação monitora de rede em nível utilizador.
Caso o valor retornado não seja para captura, a computação sobre esse pacote termina, reduzindo a sobrecarga da monitorização.
Daí que o uso de um filtro que identifique de forma célere a rejeição de um pacote, diminua consideravelmente a sobrecarga imposta ao sistema pela monitorização.

Face aos benefícios obtidos com o uso do filtro considera-se que o sistema de instrumentação do núcleo, \textit{KProbes}, poderia ser utilizado para invocar o novo sistema de filtragem criado e modificar o valor de retorno caso se mostrasse necessário.
Todavia, face ao número de vezes que a função de filtragem é invocada (uma para cada pacote, recebido ou enviado), a sobrecarga da utilização do \textit{KProbes} é de todo desaconselhavel.

Assim, além da definição de um \textit{hook} para activação e desactivação deste novo sistema, foi efectuada uma alteração ao código do \textit{Linux} na função \textit{sk\_run\_filter}, que se traduziu no retorno da decisão conjunta do filtro estático com o dinâmico, ambas realizadas no ficheiro \textit{filter.c}.

Esta alteração permitiu adicionar uma nova funcionalidade, não obstante se assistir a uma ligeira sobrecarga no sistema de monitorização, independentemente da funcionalidade estar ou não activa.

\begin{figure}[ht]
\centering
\includegraphics[scale=0.7]{run_filter.pdf}
\caption{Execução de filtragem de pacotes}
\label{fig:run_filter}
\end{figure}

\section{Informação de análise e controlo}

Com o propósito de obter algumas informações sobre o estado da computação dos diversos componentes da ferramenta e de invocar a monitorização procedeu-se à criação de alguns ficheiros no sistema de ficheiros virtual \textit{DebugFs}.

%Isto é, através dos ficheiros \textit{pid}, \textit{ppid}, \textit{tgid} e \textit{option}. 

\subsection{Informação do processo}


O MRoP foi desenhado e implementado para ser relativamente autónomo, apenas necessitando da configuração de alguns parâmetros, essenciais ao seu funcionamento.
À componente \textit{Informação de análise e controlo}, está reservado o controlo sobre os aspectos da instrumentação e do repositório.
A informação de análise apenas é adicionada, se o seu suporte for activado na compilação, permitindo assim obter métricas sobre os diferentes componentes internos ao MRoP.

\begin{figure}[ht]
\centering
\includegraphics{Ipv4_table.pdf}
\caption{Execução de filtragem de pacotes}
\label{fig:run_filter}
\end{figure}


\begin{figure}[ht]
\centering
\includegraphics{tcp_table.pdf}
\caption{Execução de filtragem de pacotes}
\label{fig:run_filter}
\end{figure}

\begin{figure}[ht]
\centering
\includegraphics{udp_table.pdf}
\caption{Execução de filtragem de pacotes}
\label{fig:run_filter}
\end{figure}


\begin{figure}[ht]
\centering
%url = http://upload.wikimedia.org/wikipedia/commons/3/3b/UDP_encapsulation.svg
\includegraphics[scale=0.7]{UDP_encapsulation.pdf}
\caption{Execução de filtragem de pacotes}
\label{fig:run_filter}
\end{figure}

%Quando o módulo da ferramenta é executado os indicadores de \textit{pid}, \textit{ppid} e \textit{tgid} são inicializados com o valor -1.

%Esta ferramenta de monitorização só irá passar a analisar os dados das chamadas ao sistema quando estes valores estiverem definidos e identificarem o processo que efectuou a chamada.

%\subsubsection{Sistema de Ficheiros}

%Dentro do sistema de ficheiros onde os \textit{sockets} estão incorporados, como apenas estamos interessados em analisar os sockets construidos para a familia \textit{AF\_INET} todos os sockets que não pertencerem a esta familia e não forem do tipo \textit{TCP} ou \textit{UDP} não serão mais analisados.
% Os \textit{sockets} que pertencem é então inicializado uma estrutura do tipo \textit{não me lembro ??? ver código} onde estão definidos o porto, o endereço e se são do tipo \textit{UDP} ou \textit{TCP}.

%Dependendo da chamada ao sistema realizada entre a função definida na entrada e a definida no retorno do \textit{KRetProbe}, são passados parâmetros que irão ser utilizados na função de retorno.


%\subsection{DebugFs}
%Criação de alguns ficheiros no sistema virtual \textit{configFs} para poder observar o comportamento da monitorização e dos pacotes que chegaram ao sistema de filtragem.
%A forte restrição de apenas um valor por ficheiro do \textit{SysFs} obriga a que para obter diferentes valores do sistema tenha de abrir diferentes ficheiros.
% Como o sistema de ficheiros \textit{proc} se sitia principalmente para os processos seria um bom candidado para a colocação de informação sobre 


%\section{Dificuldades}
% As chamadas ao sistema para o protocolo \textit{UDP} podem ser dificeis de analisar pois apesar de para o \textit{sendto} poder user utilizada a mesma técnica que foi utilizada para o \textit{connect}, para o \textit{recvfrom} pode ser mais dificil pois pode receber pacotes de multiplas fontes

\section{Conclusão}
\label{sec:implement_conclusion}
