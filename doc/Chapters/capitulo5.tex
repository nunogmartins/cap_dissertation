\chapter{Implementação da solução proposta}
\label{cap:Implementacao}

% falta falar sobre filesystem vfs e como chegar ao socket file private\_data para alem da parte de interrupts, tasklets e bottomhalfs bem como sobre os contextos de execucao
Falta falar sobre os motivos e a estrutura desejada para esta implementação

\section{MRoP e sua implementação}
\label{sec:mrop_implementation}

A implementação da solução MRoP teve em consideração vários aspectos: desenvolvimento de código minimalista, a menor perturbação de código no núcleo, utilização de API's internas, ser opaca às implementações da biblioteca \textit{PCap}.
A implementação deverá ser contida em um modulo de modo a poder ser carregado e libertado do núcleo pelo administrador.
Possibilidade de separação das diversas componentes para que cada uma possam ser melhorada em separado e a utilização de separation of concerns e reutilização de código, elementos base de qualquer programa informático.

Por cada pacote ter de atravessar toda a arquitectura de rede incluida no \textit{vfs} seria demasiado pesado para o sistema.

------- apresentar as diversas seccoes ao leitor ----------------

Nas subsecções seguintes irão ser apresentados os 4 subcomponentes do MRoP.


\section{Estado dos \textit{sockets}}

De forma a manter a informação sobre quais os endereços e portos que uma aplicação está a utilizar, sem que seja necessário consultar os sockets que esta está a utilizar, foi necessário criar um repositório de dados onde estivesse a informação relevante para as decisões do filtro de captura.

As abordagens para a criação de um repositório de dados com base nas estruturas de dados:

Necessidades de inserção, remoção e consulta. Qualquer uma destas operações deverá ser efectuada com celeridade procurando estruturas que tenham uma complexidade temporal BigO O(1) ou O(log n).

\subsection{Com suporte no núcleo}
%outro titulo alternativas disponíveis

\begin{description}

\item[BitMap]
%\subsubsection{Bitmap}

A utilização de um mapa de bits permitiria de uma modo bastante rápido e com uma reduzida utilização de memória, saber se um determinado porto estaria a ser utilizado por um determinado processo.
O núcleo tem suporte para tratamento de mapas de bits, ou seja verificação de um determinado bit num endereço de memória está activo ou não, o mesmo para afectação de um determinado bit em um endereço.
Este processo apesar de extremamente rápido, carece de modularidade na utilização de multiplos endereços, pois apenas sabemos quais os portos, mas não se sabe se são tcp, udp, por que endereço local é que estão expostos. 
Uma solução seria agrupar os diferentes mapas de bits sob a terminologia de um endereço, mas e se fosse udp ou tcp ?
E quando um processo efectua um bind sob todas as interfaces do sistema ? 
E quando é utilizada mais uma interface virtual sob uma real ? .....


\item[Listas]





%\subsubsection{Listas duplamente ligadas}
%\subsubsection{Árvores}

\item[Árvores]
Apesar de não ser necessário percorrer os elementos ou obter os indíces de forma ordenada. 

%\paragraph{Árvore Binária}

\item[Árvore Binária]

%\paragraph{Arvores Balanceadas}
\item[Árvore Balanceada]
\textit{Red-black Tree} implementada no núcleo de operação permite efectuar

Complexidade de inserção, pesquisa e remoção é O(log n), sendo n o número de elementos da árvore.

Pode existir uma penalização no desempenho, devido à necessidade de balancear a àrvore.
Os ganhos provenientes deste balanceamento, face às àrvores não balanceadas, permite manter a complexidade média de acesso aos dados em O(log(n)), ao invés de um possível decremento até O(n), ou seja a árvore degenerar em uma lista.
\end{description}

\subsection{Sem Suporte no núcleo}

\begin{description}
%\subsubsection{Tabela de dispersão}
\item[Tabela de Dispersão]
Não existe nenhuma implementação 

%\subsubsection{Bloom Filter}
\item[Bloom Filter]
bloom filters ...

\end{description}
\paragraph*{}
A estrutura de dados escolhida para a criação do repositório de dados da componente Estado dos \textit{sockets} foi a \textit{Red-black tree}.
 Esta escolha foi principalmente à performance e à existência da implementação da estrutura no núcleo do \textit{Linux}.
 Devido a esta estrutura estar presente no núcleo do \textit{linux} permitiu que a implementação da ferramenta tivesse um ciclo de implementação mais rápido devido à confiança na ``validação`` desta estrutura pelos responsáveis do núcleo do \textit{linux}.
 
\subsection{\textit{API} de comunicação entre instrumentação e repositório}

Foi criada uma \textit{API} interna ao sistema para efectuar a comunicação entre os \textit{handlers} das funções instrumentadas e o repositório dos \textit{sockets} do processo.
 Esta \textit{API} consiste nas funções de 
 Foi criada uma \textit{API} que efectua uma validação dos parâmetros passados às funções do repositório de dados e que permite uma maior modularização na modificação da estrutura do repositório de dados.

Apesar de reduzir o desempenho, porque necessita de chamar os métodos especificos ao repositório, permite que outros repositórios possam ser adicionados, permitindo modificar facilmente o código.

Apesar dos processos monitorizados serem muito dinâmicos nas comunicações, a maior percentagem de operações sobre o reposiório serão consultas/verificações.
 As restantes operações de inserção e remoção irão ter uma percentagem igual entre elas.
 É esperado que para cada inserção exista uma remoção.
 Uma monitorização a um processo durante toda a sua existência espera-se que no final o estado do reposiório seja igual ao inicio da monitorização.

\section{Instrumentação de funções do núcleo}

Como foi anteriormente descrito em \ref{subsection:network} sobre as chamadas aos sistema para utilizar as funcionalidades de rede

Foi necessário conhecer a \textit{ABI}\ref{ABI}\cite{ABI} referente às arquitecturas suportadas, \textit{x86} e \textit{x86\_64}, para a passagem de parâmetros das chamadas aos sistema.

O sistema de \textit{KProbes} permite consultar os registos do processador onde foi efectuada a chamada à função (neste caso a chamada ao sistema).
 Por isso foram definidos 6 \textit{KRetProbes} referentes às chamadas \textit{connect}, \textit{bind}, \textit{accept}, \textit{sendto}, \textit{recvfrom} e
\textit{close}.
 Para esta última \textit{close} devido à elevada utilização desta chamada ao sistema por diferentes aplicações no sistema, foi utilizada a função \textit{qqq coisa ...  ????}

------------------------------------------------------------------------------------------------------------

Para efectuar a monitorização das interacções de rede de um processo foi necessário recorrer à instrumentação de funções do núcleo.

------------------------------------------------------------------------------------------------------------

Através da instrumentação de funções do núcleo foi possível manter o contexto da execução do processo.

------------------------------------------------------------------------------------------------------------

Como apresentado e concluído na secção \ref{}, o sistema de monitorização que melhor se adequa ao problema exposto é o \textit{KProbes}.
 Deste sistema utilizou-se o \textit{KRetProbe}, de forma a instrumentar a entrada e retorno de funções.
 Obter os parâmetros de entrada das funções, principalmente o \textit{file descriptor}, tornou-se essencial.
 Para garantir que o repositório do estado do processo está coerente com o estado do núcleo, foi necessário obter o valor de retorno das funções.
 Por estas razões e porque as chamadas ao sistema têm ciclos de modificação da bastante lentos, o que evidência elevada estabilidade e consistência do núcleo, e por ser ponto de entrada do processo no núcleo foram as funções instrumentadas.

As subsecções \ref{} .... \ref{} apresentam as funções do núcleo que foram instrumentadas.

%
% faltam as subsecoes ... 
%

\subsection{Filtro de processos}
------------------------------------------------------------------------------------------------

A filtragem dos processos que efectuam as chamadas ao sistema de rede impôs um novo desafio.
 Se apenas filtrar as chamadas de um processo/pid seria apenas verificar se o pid é igual ao que se pretende é trivial e com baixa sobrecarga.
 Para um utilizador que queria analisar um processo, e não saiba qual dos fluxos do processo é responsável pela comunicação de rede, tornou-se complicado.
 Para evitar aumentar a sobrecarga no núcleo instrumentando a chamada ao sistema \textit{clone} ou função semelhante, optou-se por uma filtragem dos processos através de 3 identificadores, \textit{pid}, \textit{ppid} e \textit{tgid}.

Com esta abordagem ainda existe a possibilidade de não se obter todas as \textit{task} do processo, caso este tenha um àrvore com mais de 3 níveis, mas a sobrecarga sobre o sistema é inferior à situação de monitorização da criação de processos no sistema.
 Estes três identificadores foram escolhidos pois permitem identificar até 3 níveis da árvore de um processo.

Seria bom colocar uma imagem de uma àrvore de processo .... 

Os identificadores têm de ser escritos para os ficheiros respectivos no \textit{DebugFs}, que serão explicados na secção \ref{}.

-----------------------------------------------------------------------------------------------------

O \textit{KProbes} é um sistema de instrumentação do núcleo, que não efectua distinção entre que funções, não inline, está a efectuar a instrumentação.
Não existindo suporte no \textit{KProbes} para filtrar o processo que está a efectuar uma chamada ao sistema, foi necessário desenvolver uma metodologia que permitisse reduzir a sobrecarga desnecessária, quando a monitorizaçãoe efectuada sobre um processo que não o desejado.

Os pontos principais continuariam a ser reduzida sobrecarga e actualização permanente do(s) processo(s) a monitorizar.
Tendo estas caracteristicas como base algumas possíbilidades foram tidas em consideração, onde o principal desafio foi conseguir manter a informação actualizada.

Uma das possíbilidades foi a criação de um repositório com a informação sobre os identificadores dos processos a monitorizar, sendo necessário novamente uma estrutura de suporte a este repositório bem como funcionalidades de adição, remoção, actualização e consulta.
Este repositório teria de conter a estrutura genológica do processo a monitorizar, bem como um componente que actualize esta informação.
A actualização desta estrutura poderia ser efectuada através da instrumentação da chamada ao sistema \textit{fork} ou \textit{clone}.
Para cada vez que fossem invocadas as funções, anteriormente mencionadas, seria efectuado uma consulta ao repositório e apartir da informação obtida neste seria ou não actualizado o repositório.
Esta possibilidade, ao contemplar a remoção de dados do repositório, necessitaria também de instrumentar a função de termino de processos.
A actualização dinamica deste repositório, sem alterar código no núcleo, necessitaria de instrumentar algumas funções no núcleo o que iria afectar o desempenho do sistema não sua totalidade, pois a criação e destruição de processos pode ser elevada.

Em alternativa à anterior possibilidade, efectuou-se uma análise aos campos das estrutura que descreve um processo, a \textit{task\_struct}, para perceber de que forma estes dados se relacionam com os membros da àrvore genelógica do processo.
Desta análise obteve-se que os identificadores \textit{pid}, \textit{tid} e \textit{ppid} permitem, na grande maioria das aplicações, obter toda a àrvore, uma vez que não costumam ter uma àrvore geneológica extensa.




\subsubsection{Identificadores}

No núcleo do \textit{Linux} quando um processo é criado os identificadores \textit{pid} e \textit{tgid} são iguais.
Os processos quando efectuam



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Filtro de pacotes, extensão ao LSF}

Como foi apresentado na arquitectura, na secção \ref{subsec:Filter}, o \textit{overhead} acrescentado ao sistema mesmo sem a ferramenta estar activa é
a verificação da activação deste \textit{hook}.

\section{Informação de análise e controlo}

Devido à necessidade de obter algumas informações sobre o estado da computação dos diversos componentes da ferramenta foram criados alguns ficheiros no
sistema de ficheiros virtual \textit{DebugFs}.

Na verdade não foi só para obter o estado da computação foi também uma forma invocar o inicio da monitorização.
 Isto é, através dos ficheiros \textit{pid}, \textit{ppid}, \textit{tgid} e \textit{option}. 

\subsection{Informação do processo}

Quando o módulo da ferramenta é executado os indicadores de \textit{pid}, \textit{ppid} e \textit{tgid} são inicializados com o valor -1.

Esta ferramenta de monitorização só irá passar a analisar os dados das chamadas ao sistema quando estes valores estiverem definidos e identificarem o processo que efectuou a chamada.

\subsubsection{Sistema de Ficheiros}

Dentro do sistema de ficheiros onde os \textit{sockets} estão incorporados, como apenas estamos interessados em analisar os sockets construidos para a
familia \textit{AF\_INET} todos os sockets que não pertencerem a esta familia e não forem do tipo \textit{TCP} ou \textit{UDP} não serão mais analisados.
 Os \textit{sockets} que pertencem é então inicializado uma estrutura do tipo \textit{não me lembro ??? ver código} onde estão definidos o porto, o endereço
e se são do tipo \textit{UDP} ou \textit{TCP}.

Dependendo da chamada ao sistema realizada entre a função definida na entrada e a definida no retorno do \textit{KRetProbe}, são passados parâmetros que irão
ser utilizados na função de retorno.


\subsection{DebugFs}
Criação de alguns ficheiros no sistema virtual \textit{configFs} para poder observar o comportamento da monitorização e dos pacotes que chegaram ao sistema de filtragem.
A forte restrição de apenas um valor por ficheiro do \textit{SysFs} obriga a que para obter diferentes valores do sistema tenha de abrir diferentes ficheiros.
 Como o sistema de ficheiros \textit{proc} se sitia principalmente para os processos seria um bom candidado para a colocação de informação sobre 


\section{Dificuldades}
 As chamadas ao sistema para o protocolo \textit{UDP} podem ser dificeis de analisar pois apesar de para o \textit{sendto} poder user utilizada a mesma técnica que foi utilizada para o \textit{connect}, para o \textit{recvfrom} pode ser mais dificil pois pode receber pacotes de multiplas fontes
