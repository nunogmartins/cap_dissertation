\chapter{Monitorização de processos}
\label{cap:trabrelacionado}
O recurso à monitorização do comportamento das aplicações, permite-nos obter dados relevantes sobre os recursos realmente utilizados, de modo a proporcionar-nos um conhecimento mais profundo do seu comportamento em execuções reais, permite também analisar o plano de execução, os métodos mais executados e detectar situações de eventos interessantes.
As informações recolhidas permitem analisar o desempenho ou correcção da aplicação, sequencial ou distribuida, porquanto ao conseguir obter-se dados da utilização do \textit{cpu}, da memória, dos dispositivos de \textit{IO}, interacções, etc, é possível compreender o comportamento dinâmico das aplicações.
Daí ser comum a utilização da monitorização como auxiliar na avaliação e depuração de programas, conseguindo um bom compromisso entre a qualidade dos dados recolhidos e a perturbação das aplicações ~\cite{DuartePhd05}.
 
Na secção \ref{sect:instrumentation_overview} é apresentada a forma de efectuar a monitorização, distinguindo entre os diferentes modos de obtenção da informação.
Na secção \ref{sub:network_monitoring} é apresentada a monitorização de rede como um caso especifico da monitorização, são discutidos alguns dos problemas inerentes a esta monitorização, bem como algumas formas de as mitigar.
É igualmente apresentado o \textit{Packet Capture} (\textit{PCap}), a sua arquitectura e partes relevantes da sua implementação, bem como alguns modos que permitem melhorias no desempenho da rede e da monitorização.

Como a monitorização não é apenas exclusiva da rede, na secção \ref{sect:instrumentacao_casos_linux} são apresentadas ferramentas e mecanismos de monitorização do núcleo.
Estas ferramentas permitem não só instrumentar o código do núcleo, mas também analisar o código de aplicações em nível utilizador.

Como um dos problemas da monitorização é a obtenção da informação relevante, na secção \ref{sect:kernel_user_comm} são apresentados mecanismos de transferência de dados e, sistemas de comunicação entre o núcleo e o nível utilizador, para compreender se existem mecanismos alternativos que possam melhorar o desempenho da monitorização de rede.

Na secção \ref{sect:outras_abordagens} são apresentados exemplos de ferramentas de monitorização de rede com base em informação de processos de nível utilizador.

Por último, na secção \ref{sec:segundo:conclusion} apresenta-se uma conclusão referente aos mecanismos de monitorização e obtenção de informação.


 
%\section{Visão geral} \label{sect:descricao}
%O recurso à monitorização do comportamento das aplicações, permite-nos obter dados relevantes sobre os recursos realmente utilizados, de modo a proporcionar-nos um conhecimento mais profundo do seu comportamento em execuções mas permitem também analisar o plano de execução, os métodos mais executados, e detectar situações de eventos interessantes.
%As informações recolhidas podem servir para analisarmos o desempenho ou correcção da aplicação sequencial ou distribuida, porquanto ao conseguir-se obter dados da utilização do \textit{cpu}, da memória, dos dispositivos de \textit{IO}, interacções, etc, é possível compreender o comportamento dinâmico das aplicações.
%Daí ser comum a utilização da monitorização como auxiliar na avaliação e depuração de programas conseguindo um bom compromisso entre a qualidade dos dados recolhidos e a perturbação das aplicações~\cite{DuartePhd05}.


\section{Obtenção de informação}\label{sect:instrumentation_overview}

Os dados relativos ao comportamento das aplicações, obtidos de diferentes fontes, são normalmente coligidos e posteriormente analisados por ferramentas especializadas.
Existem diferentes formas de coligir, visualizar e até interactuar com os monitores, cada uma com as suas especificidades e capacidades próprias.
Algumas são desenvolvidas para objectivos específicos.
Tendo em vista o conhecimento geral das capacidades de cada uma, podemos analisar estes sistemas de variados pontos de vista.

\paragraph*{}
Se considerarmos, por exemplo, quanto à análise e visualização face ao instante da execução da aplicação alvo, podemos dividir os sistemas em:
 
\subparagraph*{Online -}
Enquanto decorre a monitorização da aplicação é possível observar os dados que são recolhidos pelo monitor.
Como os eventos estão a ser recolhidos e visualizados em simultâneo, apenas podemos observar a história até ao momento, mas temos uma baixa latência entre os acontecimentos e a sua observação.

\subparagraph*{Offline ou \textit{Post-Mortem} - }

A história do programa é analisada após este se ter completado, portanto a designação \textit{Post-Mortem}.
Este método permite-nos analisar integralmente a sua história e correlacioná-la.
Permite análises mais completas e computacionalmente mais exigentes.

\paragraph*{}

Se a monitorização necessitar de interactividade do utilizador, é possível defini-la de duas formas:

\subparagraph*{Activa - }

Por iniciativa explícita do utilizador, é possível inquirir o sistema de monitorização sobre o estado da computação, ou mesmo alterá-la.
Este método, por vezes descrito como \textit{computacional steering}, é a forma com maior interactividade, uma vez que permite ir analisando e modificando os parâmetros da monitorização ou mesma da aplicação.

\subparagraph*{Passiva - }
Esta forma de monitorização é especialmente utilizada em ambientes onde é relevante a obtenção da totalidade dos dados e, apenas no final, nos debruçarmos sobre a sua análise.
Esta forma é designada por passiva, pois o utilizador não tem intervenção na forma como os dados estão a ser obtidos, o que reduz a perturbação no sistema.
Quanto muito a sua acção acontece antes da execução, para configuração da informação a recolher.

\paragraph*{}
A própria instrumentação da aplicação pode ser de dois tipos: a estática e a dinâmica, cada uma com características próprias:

\subparagraph*{Estática - }

Na instrumentação estática o código instrumentado é definido em tempo de compilação ou utilizando bibliotecas próprias para o efeito, como a utilização da função \textit{assert}, que define os pontos a serem monitorizados.
Durante a execução não podem ser adicionados ou removidos pontos de análise.

\subparagraph*{Dinâmica - }

Em contraste com a instrumentação estática está a dinâmica.
É mais complexa que a estática e permite a inserção e remoção dos pontos a serem monitorizados.
Caracteriza-se pela ausência do ciclo $introduzir ponto\rightarrow compilar programa\rightarrow executar\rightarrow remover ponto$ de instrumentação.
A utilização de pontos de instrumentação dinâmica, pode ajudar a reduzir o grau de perturbação, uma vez que apenas são definidos os que se desejam observar.
Tal pode ser efectuado no início ou durante a sua execução, criando, alterando, destruindo os pontos de observação sobre os recursos monitorizados.


\subparagraph*{
%Recolha de dados
}
A recolha de dados provenientes da monitorização é uma das componentes mais sensíveis, relativamente ao grau de perturbação da monitorização.
Em geral as informações recolhidas da monitorização são armazenados em memória central sendo posteriormente armazenados em memória persistente.
Esta transferência de memória central para disco em geral deve-se a uma acção explicita do utilizador, ou então, a algum evento indicador da necessidade de guardar os dados, de forma a que novos dados possam ser armazenados em memória, uma vez que os \textit{buffers}, em memória, geralmente têm dimensão fixa.
%Caso exista algum evento que indique que o \textit{buffer} se encontra cheio ou por acção explícita do utilizador, tal é transferido para a interface com o utilizador ou armazena em memória persistente, para posterior análise.

\subparagraph*{
%Grau de perturbação
}
Existe claro a preocupação de que o sistema a ser monitorizado, tenha um baixo grau de perturbação, pois esta perturbação pode levar à alteração dos resultados obtidos e mesmo a comportamentos erráticos da aplicação (especialmente perante execuções concorrentes).
Por este motivo, diversas abordagens foram criadas, para reduzir o impacto da monitorização num sistema em produção.
Uma destas abordagens traduz-se na utilização de instruções especializadas, as quais alguns processadores dispõem para \textit{debug}, de modo a utilizar os recursos que mais se adequem à monitorização.
Estes métodos, nem sempre são utilizados, devido à sua dependência da arquitectura, o que dificulta a sua portabilidade.
Com vista a minimizar a perturbação, alguns sistemas de monitorização utilizam uma técnica de amostragem, o que permite obter indicações sobre os estado da computação a cada intervalo de tempo.
Esta técnica, em oposição à criação de um traço de execução, permite obter dados sobre os recursos apenas por amostra, limitando à partida a perturbação, enquanto que na criação de um traço de execução, é possível obter a totalidade dos eventos de forma a criar uma história completa, conduzindo a uma grande sobrecarga do sistema perante uma elevada taxa de eventos.

\paragraph*{
}
No entanto, obter dados oriundos da monitorização pode revelar-se insuficiente, se não dispusermos de uma ferramenta onde estes possam ser tratados, de modo a obtermos análises mais completas relacionado-os com os detalhes de funcionamento da aplicação monitorizada.
No entanto estas análises não serão o foco deste trabalho.

\section{Monitorização de Rede}\label{sub:network_monitoring}

As ferramentas de monitorização de rede são, em geral, baseadas na captura de pacotes de forma passiva.
Estas capturam os pacotes que fluem através da interface de rede, para posterior análise ao tráfego, que pode incidir sobre a largura de banda utilizada, principais protocolos, eventuais problemas de segurança, etc.

A monitorização das interacções dos processos com o exterior, pode ser efectuada de diferentes formas, duas destas serão apresentadas.
A primeira utiliza bibliotecas instrumentadas que obtêm os pacotes de dados quando estes chegam à aplicação, sendo que a segunda forma recorre a mecanismos genéricos do núcleo, para a monitorização de rede.
Relativamente à primeira, é necessário conhecer o código da aplicação e instrumentá-lo, obtendo-se apenas os dados que chegam à aplicação.
Este processo é específico a cada aplicação e pode ver o seu uso limitado por questões de segurança do sistema.
No que à segunda forma se refere, a monitorização é efectuada de forma genérica, não sendo intrusiva para as aplicações, necessitando apenas de efectuar a monitorização do processo e da rede, separadamente. 

\subparagraph*{Dinamismo das aplicações - }
As aplicações são dinâmicas quanto às interacções via rede (por exemplo criando e destruindo canais de comunicação).
A este dinamismo devem-se algumas dificuldades com que nos deparamos, ao monitorizar as interacções dos vários fluxos de execução dos processos.

Relativamente à monitorização das interacções com o exterior, utilizando os mecanismos do sistema de operação, este dinamismo é um factor chave, pois existem dificuldades na forma de identificar os fluxos pertencentes a um processo face aos restantes, irrelevantes na nossa análise.

\subparagraph*{Formas de reduzir o volume de dados utilizando filtros - }
A utilização de filtros na captura do tráfego de rede é uma forma eficiente de, apenas, se obter os dados relevantes, com vista à satisfação dos nossos objectivos e, são particularmente importantes, quando o volume de dados que circula na rede é extremamente elevado.
Tendo em vista a eficiência, estes filtros são implementados no núcleo do sistema de operação, baseando-se em regras simples, que podem ser combinadas para contemplar situações mais complexas.

\subparagraph*{Dificuldade de criação e alteração de filtros - }
Os filtros actualmente suportados para capturar pacotes no \textit{Linux}, são definidos \textit{a priori}, não existindo forma eficiente de os alterar dinamicamente, uma vez que a captura tem de ser interrompida a fim de ser criado um novo filtro, posteriormente aplicado, procedendo-se em seguida à retoma da captura dos pacotes, de acordo com as novas regras.

\subparagraph*{Filtros complexos - }
Para aumentar o desempenho da captura de pacotes, os filtros são aplicados o mais cedo possível, ou seja, logo que chegam à interface de rede.
Face a esta situação, o tipo de filtros que se podem aplicar têm de ser simples, baseados apenas no conteúdo do pacote.
Quando os filtros são demasiado complexos, os módulos do núcleo têm de passar grande parte da informação para as camadas superiores, de forma a puderem ser aplicados filtros mais elaborados, que analisam um nível mais abstracto da informação, presente no \textit{payload} dos pacotes, ou a relacionam com outra informação, para obterem apenas os dados relevantes.

\subparagraph*{Técnicas para o aumento de desempenho}

Diferentes técnicas têm vindo a ser desenvolvidas para aumentar o desempenho da monitorização das interfaces de rede.
Como já referido, o aumento da sobrecarga é muito penalizante, daí que esta deva ser mantida bastante reduzida, o que contribuirá para aumentar o desempenho da captura.

Actualmente a utilização de máquinas equipadas com processadores \textit{multi-core} é uma realidade, deste modo a sua utilização permite ultrapassar algumas dificuldades sentidas na captura de pacotes.
Se os processadores \textit{multi-core} atenderem em paralelo as diversas interrupções, originadas pelo envio ou recepção de pacotes, o desempenho da rede é passível de ser aumentado.
No entanto, revela-se difícil atingir este paralelismo para todas as interfaces de rede, pois nem todas estão preparadas para beneficiar de arquitecturas com múltiplos \textit{cores}.

\section{Biblioteca \textit{PCap} e \textit{Linux Socket Filtering}}\label{sect:LibPcap}

A monitorização de rede existente em muitos dos sistemas tipo \textit{Unix} e mesmo no \textit{Windows} permite capturar os pacotes de rede logo que estes chegam ao controlador de rede.
Assim, a biblioteca \textit{PCap}\cite{LibPcap} permite às ferramentas de monitorização de rede fazerem uso deste mecanismo.
Uma das principais características desta biblioteca, é a sua \textit{API} de alto nível para a captura de pacotes, que é igual em todas as plataformas.

A monitorização de rede realizada pelas ferramentas que utilizam a biblioteca \textit{PCap}, efectuam uma monitorização passiva da rede, adequando as suas análises aos pacotes recebidos, de modo \textit{online} ou \textit{offline}.
Esta monitorização é não intrusiva para o código das aplicações e, dependendo do modo como é efectuada, pode ter algum impacto no desempenho destas ou do sistema na sua globalidade.

Para filtrar os pacotes indesejados a biblioteca \textit{PCap} utiliza filtros baseados no \textit{Berkeley Packet Filtering} (\textit{BPF}), normalmente implementados no núcleo de sistema, de modo a que a monitorização se torne mais eficiente e menos intrusiva.

Em seguida é apresentada a arquitectura da biblioteca \textit{PCap} e o seu suporte no \textit{Linux}, \textit{Linux Socket Filtering}.

\subsection {Arquitectura}
\label{sect:architecture_libpcap}
A arquitectura do \textit{Packet Capture} (\textit{PCap}) divide-se em duas partes: a biblioteca a nível utilizador, e a implementação do \textit{Linux Socket Filtering} no núcleo de sistema.
Como anteriormente referido, a bibilioteca em nível utilizador é constituida por uma \textit{API} homogénea, que oferece às ferramentas de monitorização de rede um mecanismo para efectuar as suas análises ao tráfego.
As funções auxiliares da biblioteca efectuam chamadas ao sistema de modo a interagirem com o mecanismo de monitorização de rede do \textit{Linux}, \textit{Linux Socket Filtering}, presente no núcleo.

\begin{figure}[htbp]
       \centering
       \includegraphics[scale=0.7]{tcpdump.jpg}
%       \includegraphics[scale=0.5]{tcpdump}
       \caption{Arquitectura da biblioteca \textit{PCap} e do \textit{LSF}}
      \label{fig:pcap_architecture2}
\end{figure}

\subsection{Biblioteca}

A biblioteca em nível utilizador, ao ter uma \textit{API} homogénea entre plataformas, permite aos programadores desenvolverem mais rapidamente ferramentas de monitorização de rede multiplataforma, sendo utilizada pela generalidade das ferramentas de monitorização de rede, tais como o \textit{TcpDump}, o \textit{Wireshark}, o \textit{Snort}, etc.
Esta biblioteca como é multiplataforma, permite ao programador utilizá-la nos principais sistemas de operação, dado que a \textit{API} da biblioteca \textit{PCap} é transparante relativamente à implementação, esta sim, específica a cada plataforma.

No \textit{Linux} para cada utilização da biblioteca \textit{PCap} é criado um \textit{socket} da família \textit{AF\_PACKET}.
Como este \textit{socket} comunica, directamente, com a interface de rede permite que sejam activadas e, desactivadas propriedades das mesmas.
Uma destas propriedades é o modo promiscuo, geralmente utilizado para efectuar a captura de pacotes que não pertencem às comunicações da máquina que efectua a monitorização.
Apesar desta funcionalidade ser amplamente utilizada para análisar a rede, para o âmbito desta dissertação é totalmente desnecessária, dado que os pacotes, a serem recolhidos para análise, são os pretencentes a processos da máquina.
É através deste \textit{socket} que é efectuada a captura dos pacotes que atravessam a interface de rede.
Um dos parâmetros para a monitorização é a interface sobre a qual irá ser efectuada, ou um modo especial que permite que todas as interfaces possam ser monitorizadas.

A fim de minimizar e capturar apenas os pacotes relevantes para as análises, pode ser necessário filtrar os pacotes não relevantes.
Deste modo a biblioteca permite efectuar diversas formas de filtragem, quer em nível utilizador, para filtros mais complexos, quer no núcleo com filtros apenas baseados nos metadados dos pacotes.
Se a filtragem for efectuada exclusivamente em nível utilizador, o filtro a ser aplicado indica que todos os pacotes devem ser capturados, senão a ferramenta que utiliza a biblioteca deve especificar um filtro utilizando para isso as instruções pertencentes à biblioteca \textit{PCap} que as irá traduzir e optimizar para uma outra linguagem (\textit{BPF}
 


Caso exista a necessidade de filtrar os dados a capturar é necessário aplicá-lo ao \textit{socket} criado através da chamada ao sistema \textit{setsockopt}, passando em argumentos o canal e o filtro a ser executado a cada pacote.
É possível obter estatisticas, relacionadas com a captura e filtragem de pacotes, estas são também obtidas através de \textit{ioctls} efectuados sobre o canal de recepção da monitorização.
Estas funcionalidades estão agregadas à biblioteca, para que o programador não tenha de se preocupar com os mecanismos internos relativos à manipulação da monitorização de rede no núcleo.

Para se efectuar a captura de pacotes, é necessário especificar qual a interface de rede a monitorizar.

Como o número de pacotes que atravessa a interface de rede é elevado, existe a possibilidade de capturar segundo critérios baseados nos dados dos pacotes.
Como verificado anteriormente, quando o número de dados da monitorização é elevado, e nem todos os dados capturados são relevantes para as análises, estes são filtrados, de modo a apenas serem utilizados para análise os dados relevantes.
Daí que a biblioteca \textit{PCap} tenha uma linguagem própria para a especificação de filtros, sendo posteriormente traduzidos para a linguagem \textit{BPF} para serem aplicados ao canal, obtendo assim apenas os pacotes relevantes para as análise a efectuar.

Se for necessitario filtrar pacotes, é necessário especificar o filtro a utilizar, recorrendo às instruções presentes na biblioteca \textit{PCap}, que através da função  \textit{pcap\_compile} o traduzirá e optimizará para o conjunto de instruções do \textit{BPF}, sendo posteriormente aplicado no núcleo através da função \textit{setfilter}.
Se o filtro for demasiado complexo, não poderá ser aplicado no núcleo, sendo apenas possível aplicá-lo em nível utilizador, perdendo algum desempenho.
Antes da introdução do novo filtro no canal, este tem de ser objecto de drenagem, para receber apenas os pacotes do novo filtro.
Este modo de filtragem, evita imediatamente a captura de pacotes irrelevantes para a análise e permite que aqueles que não são visíveis às aplicações, devido à \textit{firewall} do \textit{Linux}, possam ser capturados e analisados pelas ferramentas de monitorização de rede.

A arquitectura de rede do núcleo de sistema \textit{Linux}, utiliza \textit{socket buffers}, que contêm dados referentes às diferentes camadas da pilha de rede \textit{TCP/IP}.
Esta estrutura que dispõe de toda a informação sobre o pacote, a receber pela aplicação, é igualmente utilizada nos sistemas de monitorização em nível utilizador.
A monitorização da rede é efectuada directamente no controlador da interface de rede, utilizando para isso um \textit{socket} \textit{AF\_PACKET}.

Enquanto que as aplicações apenas recebem os dados (\textit{payload} final), este \textit{socket} recebe a totalidade do pacote.
Caso o número de \textit{bytes} dos pacotes sejam superiores ao indicado no filtro, o pacote é cortado até ao tamanho indicado neste.

\subsection{Linux Socket Filtering}



O módulo \textit{AF\_PACKET} permite activar o modo promiscuo da interface a monitorizar, ou seja, permite a captura de pacotes que não são destinados à máquina utilizada.
Na versão actual do núcleo de sistema do \textit{Linux} (2.6.39), o \textit{socket} \textit{AF\_PACKET} pode utilizar um sistema de partilha de \textit{buffer} (\textit{MMAP}), com o espaço de utilizador.
Neste caso, cabe ao utilizador definir explicitamente a forma como pretende utilizar o \textit{socket}. 
Para atingir este objectivo o utilizador tem de pedir ao núcleo, uma região de memória, sendo esta, posteriormente indicada como argumento de configuração do \textit{socket}.

Como o referido anteriormente, o \textit{AF\_PACKET}, permite a comunicação directa com o controlador da interface de rede, possibilitando capturar os diversos pacotes ainda antes destes poderem ser filtrados pela \textit{firewall}, presente no núcleo de sistema, neste caso o \textit{netfilter}.
Podem ser aplicados filtros aos \textit{sockets} de modo a aumentar a eficiência na captura dos pacotes, excluindo aqueles que são irrelevantes para a monitorização.

O \textit{Linux Socket Filtering} (\textit{LSF}) é derivado do \textit{Berkeley Packet Filtering} (\textit{BPF}) que é o \textit{standard} de \textit{de facto} para a criação de filtros para a captura de pacotes de rede, no núcleo de sistema.
Este sistema de captura e filtragem permite aos administradores, definir e afectar filtros ao \textit{socket} da familia \textit{PACKET}.
Os filtros definidos são descritos numa linguagem simples, de forma a efectuarem com rapidez a selecção dos pacotes a capturar, rejeitando todos os outros.
A linguagem utilizada para a criação dos filtros é traduzida para o \textit{Instruction Set}, definido no \textit{BPF}.
Este \textit{Instruction Set} utiliza operadores lógicos de forma a combinar as regras definidas nos filtros, criando-se apenas um filtro a ser aplicado aos pacotes.~\cite{Mccanne92thebsd}.

\subsection{Limitações e optimizações}
Apesar da \textit{API} da biblioteca \textit{PCap} ser igual em diferentes plataformas (\textit{Windows}, \textit{Linux}, \textit{FreeBSD}, etc), o desempenho desta pode variar.
Quando existe pouco tráfego de rede as diferenças são pouco notórias, mas logo que este se intensifica, estas acentuam-se bastante, como demonstra o estudo \textit{Improving Passive Packet Capture: Beyond Device Polling} \cite{Deri2004}.

De modo geral, para a avaliar o desempenho da monitorização de rede, é frequente utilizar-se uma métrica, que nos permita determinar a percentagem de pacotes que é possível capturar, sem que se verifiquem perdas.
Esta métrica é calculada sabendo o número de pacotes que atravessam uma determinada porta de um \textit{router ou switch}, e compará-lo com o número de pacotes capturados na interface.
Uma variante desta medida de desempenho é combiná-la com o máximo número de regras que é possível aplicar, sem que se assista à perda de pacotes.
É particularmente importante conhecer o número máximo de pacotes capturados ou regras aplicáveis aos filtros, afim de determinar a velocidade máxima expectável de captura.
Quanto mais eficiente for a filtragem, menor o número de pacotes transferidos para as aplicações, o que se traduz numa menor sobrecarga para o sistema, aumentando o seu desempenho.

\paragraph{Captura de pacotes com \textit{TimeStamp}}
% como etiquetar os pacotes 
Um dos pontos que pode influenciar negativamente o desempenho da obtenção de pacotes, é a necessidade de colocar nestes, uma estampilha temporal, com o tempo da sua chegada ao sistema.
A biblioteca \textit{PCap} pode obter a estampilha de duas formas distintas.
Assim, se a interface de rede fornecer a estampilha temporal associada ao pacote, a biblioteca pode utilizar este valor, caso contrário, será necessário obter a estampilha temporal da chegada do pacote ao sistema.
A forma de obtenção da estampilha pela biblioteca \textit{PCap}, processa-se através da função \textit{gettimeofday}, o que incorre numa maior sobrecarga do sistema face à solução anterior.

\paragraph{Captura com \textit{dns} activo}

Como já referido a biblioteca \textit{PCap} é utilizada por diversas ferramentas de análise do trafego de rede, que dela tiram partido.
Uma destas ferramentas é o \textit{TcpDump}, este utiliza a biblioteca \textit{PCap} para efectuar 

A biblioteca \textit{PCap}
\textit{TcpDump} com parametro n de \textit{dns} para obter os nomes de dominios sempre que possivel

\paragraph{Captura especificando tamanho máximo de 65535 para pacotes}

MTU de 1500 ethernet

\paragraph*{PACKET\_MMAP}

Com base na técnica \textit{MMAP}, foi criado o \textit{PACKET\_MMAP}, disponível a partir da versão 1.0.0 da biblioteca \textit{PCap}.
Este módulo permite algumas melhorias em termos de desempenho, visto que foi reduzido o número de cópias efectuadas, face à anterior versão 0.9.8 da biblioteca \textit{PCap}.
Esta técnica consiste na utilização de um bloco de memória pertencente ao processo que irá utilizar o \textit{socket}, de modo a que quando seja necessário passar um pacote do núcleo para a ferramenta, não seja necessário efectuar uma cópia da memória onde reside o pacote.
Este novo método tem de ser acompanhado por contadores/índices de acesso à memória, dado que, esta zona de memória é acedida de forma circular.
Apesar de melhorar significativamente o número de cópias de dados, como os blocos de memória para a introdução de pacotes é efectuada de modo estático, existem apenas um número fixo que podem ser alocados.
Assim, se o ritmo de escrita dos pacotes na zona de memória for superior ao ritmo de leitura, podem existir perdas de pacotes, dado que não existe espaço suficiente para alocar os novos, enquanto os anteriores não forem consumidos.

----------------------------------------------------------------------------------------------------------

Para além destas modificações no \textit{PACKET\_MMAP}, o núcleo de sistema de operação \textit{Linux} na sua versão 2.6, passou a contar com a nova \textit{API} de rede (\textit{NAPI}).

Se as interfaces de rede suportarem um mecanismo de mitigação de interrupções, é possível obter melhores resultados, conforme \cite{Deri2004}.

----------------------------------------------------------------------------------------------------------

\paragraph*{PF\_RING}

Este é um novo módulo para o núcleo de sistema, criado com base em duas técnicas \textit{mmap} e \textit{ring\_buffers} anteriormente descritas.

Este módulo difere na abordagem utilizada no \textit{PACKET\_MMAP}, porquanto nesta a memória é mapeada entre a ferramenta e o controlador da interface, enquanto que no \textit{PACKET\_MMAP} a memória é mapeada entre a ferramenta e um \textit{buffer} externo ao controlador da interface, mas interno ao núcleo de sistema.
Esta abordagem permite que os dados fiquem disponíveis para a aplicação directamente, verificando-se a inexistência de cópia dos dados do \textit{buffer} do controlador, para o \textit{buffer} partilhado entre a ferramenta e o núcleo\cite{PFRING}.
 
\paragraph*{PF\_RING com DNA (Direct NIC Access)}
Baseando-se na técnica anteriormente descrita de utilizar um \textit{buffer} partilhado entre a ferramenta de monitorização e o controlador, assiste-se a uma evolução desta técnica, ao permitir que a interface de rede partilhe um \textit{buffer} com a ferramenta de monitorização, possibilitando que os pacotes passem directamente para esta\cite{IntroPF_RIDNADirecNICAcces}.
Esta partilha é efectuada utilizando \textit{mmap}, \textit{ring\_buffers} e \textit{DMA}.
Para ser utilizada esta técnica, é necessário que a interface de rede, permita a utilização de memória partilhada e \textit{DMA}.

\paragraph*{}

Diversos esforços no sentido de aumentar o desempenho da captura de pacotes têm sido efectuados.
Relativamente ao \textit{software}, são conhecidos esforços na utilização da técnica de \textit{mmap}, por forma a reduzir o número de cópias de dados entre as aplicações e o núcleo de sistema.
Igualmente no \textit{hardware}, tem-se assistido a uma evolução, no sentido de reduzir as interrupções efectuadas ao \textit{cpu}, adicionando nas interfaces de rede processadores dedicados às funcionalidades presentes no núcleo, de modo a libertá-lo da execução destas tarefas.


\subsection{Optimizações na Estrutura de Rede}

Com a utilização de redes a 100 ou 1000 \textit{Mbps} o número de interrupções que são efectuadas, a cada pacote que chega a interface de rede, é muito elevado.
Isto leva a que, para cada pacote a ser transferido entre o \textit{buffer} da interface de rede e a memória central, seja necessário uma interrupção ao \textit{cpu}.
Quando a utilização de rede é baixa, este modo de atendimento não comporta uma elevada sobrecarga no sistema, mas a partir de um certo valor, o número de atendimentos de interrupções é tão alto que não é possível realizar mais trabalho.

Foi criada uma nova \textit{API} de atendimento de interrupções do processador, oriundos das interfaces de rede, com o objectivo de aumentar o desempenho da utilização de rede de elevado débito.
Esta nova \textit{API}, permite desligar a atenção do processador a novas interrupções, oriundas da interface de rede, durante um certo período de tempo.
Este tempo foi definido, de forma a que não se verifiquem situações de elevada latência na chegada dos pacotes às aplicações.

Actualmente, a arquitectura de rede, está balanceada de forma a mudar o modo de atendimento de interrupções para \textit{NAPI}, caso existam demasiadas interrupções por unidade de tempo~\cite{administrator:napi}.

Utilizando esta nova \textit{API}, é possível explorar um escalonamento mais eficiente das interrupções, em situações de intensa actividade da interface de rede e do processador.
O \textit{NAPI} apenas pode ser aplicado nos caso em que os controladores das interfaces de rede estejam preparados para utilizar alguma forma de mitigação da interrupção, caso contrário esta \textit{API} não é aplicada, resultando em interrupções por cada pacote, enviado ou recebido.

A utilização desta nova \textit{API} permite diminuir o número de trocas de contexto entre o controlador da interface e o núcleo de sistema.
Sempre que o \textit{cpu} atende uma interrupção de rede, obtém um número maior de dados, que combinado com um sistema de memória partilhada aumenta substancialmente o desempenho.

\paragraph*{Sistemas \textit{multi-core} e multi-processador}

Com o aparecimento de sistemas \textit{multi-core} e \textit{multi-processador} a que a generalidade do público tem acesso, a paralelização de código ou a forma de tirar partido destas arquitecturas, que permitem um melhor aproveitamento dos recursos, assumem uma particular importância.
De modo a tirar partido das arquitecturas \textit{multi-core}, é necessário que o controlador e interfaces de rede, os \textit{buffers}, e os controladores de \textit{Direct Memory Access} (\textit{DMA}), sejam modificados de forma a conhecerem esta estrutura.
É pois, determinante um esforço conjunto envolvendo todas estas componentes, com vista à obtenção do máximo rendimento destas arquitecturas\cite{Deri:2010}.



\section{Sistemas de monitorização no núcleo do \textit{Linux}}\label{sect:instrumentacao_casos_linux}

A monitorização do núcleo é uma das melhores formas de conhecer como os recursos da máquina são partilhados entre o núcleo e os processos, assim nesta secção são apresentados ferramentas e mecanismos de monitorização do núcleo.
A utilização dos sistemas de monitorização ao nível do núcleo, permitem efectuar a monitorização genérica dos processos, de forma não intrusiva para as aplicações.
Ao efectuar a monitorização no núcleo, a sobrecarga imposta ao sistema é menor que em nível utilizador, por ser possível recolher apenas as informações relevantes, evitando filtrar os elementos não relevantes, para análise.\todo{duvida se pode ser assim}

Neste documento constam apenas mecanismos e ferramentas de monitorização dinâmicas, pois apenas estas são as desejadas para a criação de uma componente de monitorização de rede orientada ao processo.
De entre as ferramentas de monitorização dinâmica analisadas é possível agrupá-las em duas categorias: eventos pré-definidos e instrumentação dinâmica.
Na categoria instrumentação dinâmica existem dois sistemas mais relevantes: o \textit{KProbes} e o \textit{Linux Kernel Stace Tracer}, enquanto que para os eventos pré-definidos foram verificados o \textit{Linux Trace Toolkit} e o \textit{OProfile}.
Estes quatro sistemas são apresentados em seguida considerando as suas categorias:

\subsection{Eventos pré-definidos}

Nesta categoria encaixam-se duas ferramentas o \textit{Linux Trace ToolKit} e o \textit{OProfile}.
Em cada uma destas ferramentas a monitorização é efectuada sobre pontos previamente definidos, não permitindo a adição de novos pontos de monitorização.
Cada um destas ferramentas analisa todo o sistema, sendo a filtragem extra dos eventos efectuada em nível utilizador.
%\todo{ver}
Como os eventos detectados através destas ferramentas geram um mapa de execução, a utilização de apenas alguns eventos pré-definidos não é limitativa de uma ferramenta.

\subsubsection{Linux Trace ToolKit}\label{cap:linux_trace_toolkit_overview}

% O Linux Trace Toolkit é uma ferramenta de ``tracing''
% Utiliza o Klog com repositorio da informação obtida do kernel.
% Nesta versão a comunicação entre o kernel e aplicação em user space é efectuada utilizando o relayfs.
% O RelayFs é um sistema de ficheiros para comunicação entre o código dentro e fora do núcleo de operação.
%A utilização desta ferramenta em sistemas de tempo real é um bom indicador da sua performance.

O \textit{Linux Trace ToolKit} (\textit{LTT}) é uma das ferramentas mais utilizadas efectuar um traços de execução do núcleo \textit{Linux}.
Esta ferramenta foi criada no final da década de 1990, sendo posteriormente subsituido em 2005 pelo \textit{Linux Trace ToolKit new generation}, (\textit{LTTng}), projecto derivado do \textit{LTT}.
O \textit{LTT} é constituído por quatro componentes: o \textit{Kernel Patch}, o \textit{Kernel Module} o \textit{Trace Daemon} e o \textit{Data Decoder} tal como é visivel na figura \ref{fig:ltt_arch}.
É através do \textit{Trace Daemon} que o utilizador pode comunicar com o sistema de monitorização.
Os dados recolhidos têm diversos valores tais como o nome da função, o tempo, e o identificador do processador, pelo menos estes atributos de modo a conseguir construir os traço de execução.
O \textit{LTT} e o \textit{LTTng} são ferramentas de monitorização dinâmica que efectuam um traço de execução.
Estas ferramentas tiram partido dos mecanismos de instrumentação do núcleo de modo a obter dados que permitam efectuar o traço de execução.

Para além do \textit{daemon} em nível utilizador existem outras ferramentas pertencentes ao \textit{LTT} para efectuar análises aos dados recolhidos durante a monitorização.

Os dados provenientes da monitorização são recolhidos através do sistema de ficheiros virtual \textit{RelayFs}.

\begin{figure}[!htb]
       \centering
       \includegraphics[scale=0.7]{ltt_arch.png}
       \caption{Arquitectura do \textit{Linux Trace Toolkit} \cite{Yaghmour:2000:MCS:1267724.1267726}}
	\label{fig:ltt_arch}
\end{figure}

\cite{Yaghmour:2000:MCS:1267724.1267726}
foi substituída pelo \textit{Linux Trace Toolkit New Generation}.
O \textit{Linux Trace Toolkit New Generation}, e permite utilizar mecanismos como o \textit{KProbes}, o \textit{Tracepoints}\cite{Mathieu2009} e \textit{Linux Kernel Markers}\cite{Mathieu2009} para efectuar as suas monitorizações.
Os \textit{Tracepoints} e Linux \textit{Kernel Markers} fazem parte da instrumentação estática pertencente ao núcleo de sistema do \textit{Linux}.
A transferência dos dados do núcleo de sistema para a aplicação, é efectuada utilizando o sistema de ficheiros virtual \textit{RelayFs}.

%\subparagraph{Linux Trace Toolkit Viewer - }\label{cap:lttv_overview}
O \textit{Linux Trace Toolkit Viewer (LTTV)} é um projecto desenvolvido em paralelo com o \textit{LTT} e \textit{LTTng}, de modo a criar uma análise visual dos dados recolhidos por estas aplicações.
Esta ferramenta possibilita igualmente realizar um traço de execução, uma vez que os dados recolhidos contêm uma estampilha temporal, do momento em que foram obtidos.
 
\subsubsection{OProfile}\label{cap:Oprofile_overview}
O \textit{OProfile} é outra das ferramentas de monitorização do núcleo, esta efectua um perfil de execução das funções do núcleo, através de amostragem. 
Com o \textit{OProfile}, em vez de a cada evento utilizar uma função para obter os dados, apenas a utiliza decorridos um certo número de eventos.
O recurso a este critério permite ao \textit{OProfile} ser menos perturbador, uma vez que nem sempre é necessário o universo dos eventos que as ferramentas de monitorização capturam, mas tão somente uma amostra \ref{fig:oprofile_arch}.
Deste modo ao utilizar a amostragem, o \textit{OProfile}, beneficia de um menor grau de perturbação no sistema\cite{Will:TuninProgrOProf}.
% ser menos perturbador do sistema.
% it uses data sampling ... the others don't

\paragraph*{}
O \textit{OProfile} é uma ferramenta que efectua um perfil de utilização dos recursos da máquina, utilizando para o efeito a técnica de amostragem.
Esta ferramenta é composta por três componentes principais, o módulo no núcleo (\textit{oprofile driver}), o \textit{daemon}/processo em nível utilizador que recolhe os dados obtidos da monitorização pelo módulo do núcleo (\textit{opcontrol}) e o \textit{opreport} e \textit{opannotate} que permitem criar relatórios, tal como se pode constatar na figura \ref{fig:oprofile_arch}.

\begin{figure}[!htb]
       \centering
       \includegraphics[scale=0.7]{oprofile_arch.jpg}
       \caption{Arquitectura do \textit{OProfile} \cite{Will:TuninProgrOProf}}
	\label{fig:oprofile_arch}
\end{figure}

O \textit{OProfile} não efectua apenas o perfil de utilização do núcleo \textit{Linux}, pois também cria o perfil de utilização dos processos que estão em execução na máquina.
Este perfil é criado com o auxilio do sistema de ficheiros virtual \textit{ProcFs}, que indica quais os processos em execução e respectivas zonas de memória utilizadas por estes.

O \textit{OProfile} regista os valores do \textit{program counter} (registo do processador que contém a proxima instrução a executar) e o tempo quando quando foi  ------ é triplo com estes dados e as zonas de memória e qual o processo corrente consegue efectuar o perfil de utilização do processo.

De modo a reduzir a sobrecarga / contenção utiliza buffers por cpu ... 

\subsubsection{DProbes}
O \textit{DProbes} utiliza o \textit{KProbes} como suporte para efectuar a instrumentação dinâmica do núcleo de sistema.
Como a criação de pontos de análise é escrito em linguagem C ou \textit{assembly}, foi desenvolvida uma linguagem de mais alto nível de forma a simplificar a utilização desta aplicação.

Após se obterem os dados, estes podem ser transferidos para um ficheiro, para o \textit{daemon de logging} do núcleo de sistema, ou para uma porta série.
Existe, igualmente, a opção de interoperabilidade com o \textit{Linux Trace Toolkit}\cite{DProbes}.

%\subsubsection{SystemTap}\label{cap:Systemtap_overview}
\subsubsection{SystemTap}
O \textit{SystemTap} é uma ferramenta que possibilita o desenvolvimento de módulos para o \textit{KProbes}, utilizando uma linguagem específica, de forma a ser segura e fácil de trabalhar.
Uma vez que os dados gerados estão no espaço de endereçamento de memória do núcleo, e o programa que os analisará se situa no espaço de endereçamento do utilizador, é necessário efectuar uma transferência de dados de um para outro espaço.
O \textit{SystemTap} efectua esta transferência, recorrendo à utilização do sistema de ficheiros \textit{ReplayFs}, onde é possível escrever de forma rápida, sem comprometer a segurança do sistema\cite{Donovan2007,Jones2009}.

Apesar de, no pacote de aplicações desta ferramenta, existir um visualizador gráfico de dados recolhidos pelo \textit{SystemTap}, este só consegue analisar os \textit{TapSets} pré-definidos no \textit{SystemTap}.
Para ultrapassar esta limitação, novas ferramentas estão a ser desenvolvidas.
Uma destas ferramentas designada por \textit{bootlimn}, está actualmente a ser desenvolvida no \textit{Google Summer of Code}, com o objectivo de utilizar o \textit{SystemTap} para recolher informações sobre o arranque do sistema, agregando estes dados no formato \textit{XML}.
Os dados recolhidos, permitem visualizações gráficas do processo de inicialização do sistema, bem como da utilização de disco e \textit{CPU}.
Outro projecto conhecido como \textit{Systemtap GUI}, que engloba o \textit{System Tap Editor Plug-in} para a ferramenta Eclipse, é um ambiente onde podem ser analisados e visualizados os dados recolhidos pelo \textit{SystemTap}.

%O \textit{SystemTap} actualmente está a ser desenvolvido por empresas de reconhecido mérito internacional, nomeadamente a \textit{Red Hat}, a \textit{IBM}, a \textit{Hitachi} e a \textit{Oracle}.




% outra abordagem 

\subsection{Suporte à monitorização}

Nas secções anteriores foram apresentadas ferramentas de monitorização e os seus mecanismos para lidar com a monitorização.
As ferramentas são importantes quando existe a necessidade de efectuar análises aos dados obtidos.
Nas ferramentas os diversos componentes que as constituem estão muito interligados dificultando, por vezes, a sua integração com outros componentes.

Por seu lado os mecanismos devem ser genéricos, tirando partido das arquitecturas, para que possam ser desenvolvidas ferramentas que os possam utilizar.


Como suporte à monitorização destaca-se o mecanismo \textit{KProbes} que é um mecanismo de instrumentação dinâmica do \textit{Linux}.


e a ferramenta \textit{Linux Kernel Stace Tracer}.

Em \todo{} ambos é possível definir novos pontos, funções ou eventos a serem monitorizados, as funcionalidades já existentes nestas ferramentas.

\subsubsection{KProbes}\label{sect:KProbes_overview}

O \textit{KProbes} é um mecanismo de instrumentação dinâmica do núcleo do \textit{Linux}.
A \textit{API} permite que ferramentas, como o \textit{DProbes} ou o \textit{SystemTap} possam aceder às suas funcionalidades.
Esta encontra-se na versão principal do núcleo do sistema \textit{Linux}, desde a versão 2.6.9, o que indica tratar-se de uma ferramenta bastante estável~\cite{kernel_debug_printk_on_fly,KProbesSite}.

Utilizando o \textit{KProbes} existem três tipos de instrumentação que podem ser efectuadas: o \textit{KProbe}, o \textit{JProbe} e o \textit{KRetProbe}.
Cada um destes três tipos é especifico de uma determinada funcionalidade.

\begin{itemize}
 \item \textbf{KProbe - } Utilizando o \textit{KProbe} pode analisar-se uma instrução e, para isso tem de ser indicada a distância da instrução relativamente ao inicio da função instrumentada.
A indicação da função a instrumentar, pode ser definida recorrendo ao seu nome, ou ao seu endereço de memória.

\item \textbf{JProbe - } Um \textit{JProbe} destina-se a analisar os parâmetros, da função a instrumentar.
Quando é declarado um \textit{JProbe} a função de \textit{handler} tem de conter os mesmos tipos de argumentos que a função que se destina a ser instrumentada, de forma a serem monitorizadas.
 
 \item \textbf{KRetProbe - } Este tipo de análise tem como objectivo obter o valor de retorno da função que se pretende analisar.
Para efectuar esta operação é utilizada a técnica do trampolim~\cite{Hollingsworth94dynamicprogram}, uma vez que uma função pode terminar em pontos diversos.

\end{itemize}

\begin{figure}[!htb]
       \centering
       \includegraphics[scale=0.75]{KProbesArchitecture.jpg}
       \caption{Arquitectura do \textit{Kprobes} }
	\label{fig:kprobes_arch}
\end{figure}

\begin{figure}[!htb]
       \centering
       \includegraphics[scale=1.0]{KProbeExecution.png}
       \caption{Execução de um \textit{KProbe} }
	\label{fig:kprobe_execution}
\end{figure}

Para se obterem informações sobre as funções ou instruções que estão a ser monitorizadas, o \textit{KProbes} disponibiliza-as através de um ficheiro no \textit{DebugFs}.
Para utilizar o \textit{KProbes} é necessário criar um módulo para o núcleo do sistema de operação, com informações relativas às rotinas a instrumentar.
Para além destas, o módulo tem de conter igualmente os \textit{handlers} de análise, assim como outros parâmetros necessários à realização da instrumentação.

Quando o módulo é inserido no núcleo de sistema, o registo dos \textit{handlers} das funções a serem instrumentadas é efectuado de forma atómica.
A execução do \textit{KProbes} não utiliza nenhum \textit{mutex} ou outra forma de controlo de concorrência, apenas funciona com a preempção desligada.
Dependendo do contexto, os \textit{handlers} podem ser executados com as interrupções desligadas.

A instrumentação, processa-se copiando a instrução que se quer analisar para uma zona de memória, e substituindo essa instrução no código por uma interrupção (\textit{int3}).
Quando possível, o \textit{KProbes} utiliza instruções do processador especializadas na depuração de modo a minimizar o grau de perturbação.
A utilização da instrução \textit{int3} tem problemas de desempenho associados, por isso foi desenvolvido uma modo alternativo para efectuar a instrumentação.
O método utilizado foi através da utilização de um \textit{jmp} incondicional, desta forma é possível obter um desempenho superior à utilização da instrução \textit{int3}.
Apesar de poder ser aplicado em diversas situações, não pode ser sempre utilizado dado que instrucções que dependam do registo do processador \textit{eip} ou \textit{rip}, não podem usufruir desta optimização.

Apesar de ser possível instrumentar praticamente todo o núcleo do sistema de operação, existem algumas situações que podem requerer alguma perícia na forma como são tratadas.
Quando o compilador realiza substituição de funções por código \textit{inline}, as instruções que anteriormente estavam dentro da função passam a integrar o ponto onde foram substituídas, deixando de existir um ponto de entrada na função.
Assim sendo, a função deixa de existir, impossibilitando a instrumentação destas funções.
Não existe a possibilidade de instrumentar recursivamente uma função, ou seja, se uma função está a ser instrumentada e nas funções de \textit{handler} essa função é chamada, o \textit{KProbes} detecta que já está em execução e não permite que seja novamente interrompido, incrementando uma variável que indica que existiu um \textit{miss}.

Como anteriormente referido, este mecanismo de instrumentação do núcleo é utilizado por diversas ferramentas, de modo a instrumentar dinamicamente código pertencente ao núcleo.
Duas das ferramentas que tiram partido deste mecanismo são: \textit{DProbes} e o \textit{SystemTap}.

%\subsubsection{DProbes}\label{cap:Dprobe_overview}

\subsubsection{Linux Kernel State Tracer}
% Linux Kernel State Tracer(LKST) records information as trace data about events in the Linux Kernel. It records various events like process context switch, send signal, exception, memory allocation, send packet, and so on. 

O \textit{Linux Kernel State Tracer(LKST)} obtém informações referentes ao núcleo de sistema, de forma a criar um traço de execução, e consegue capturar diferentes eventos como trocas de contexto, envio de sinais, alocação de memória, transmissão de pacotes, etc.

% a\subparagraph{DJProbe}
\label{cap:djprobe}
  % Este sistema é mais leve devido à forma como é feito o ``trap'' pois não usa o int 3
% Duvidas na forma como é controlado o sistema na presença de processadores maquinas com multiplos processadores.
% Não utiliza o int 3 para fazer o trap por isso segundo o artigo fica mais leve que o KProbe e o JProbe.
% DJProbe  quer dizer Direct Jump Probe faz um jmp e não usa o int 3.
Actualmente, está a ser desenvolvido um subprojecto do \textit{Linux Kernel Stace Tracer} designado por \textit{Direct Jump Probe}.
O \textit{Direct Jump Probe} é uma optimização à utilização do \textit{trap int3}, presente em alguns processadores, e que pode trabalhar em conjunto com o \textit{KProbes}.
Esta optimização pode ser verificada no relatório\cite{Hiramatsu2005}.


\subsection{Comparação entre os diferentes sistemas de instrumentação}
% \todo{completar esta tabela}
\begin{table}[h!]
\begin{center}
\caption{Tabela Comparativa dos sistemas de instrumentação}
\label{tab:inst_compare}
\begin{tabular}{|l||c|c|c|}
\hline
Instrumentação & Amostragem / Traço & Análise de Parâmetros & Deamon \\
\hline
KProbes & Traço & Permite & Não necessita \\
\hline
LKST & Traço & Permite & Necessita \\
\hline
LTT & Traço & Não permite & Necessita \\
\hline
OProfile & Amostragem & Não permite & Necessita \\
\hline

\end{tabular}
\end{center}
\end{table}

%Da observação da tabela \ref{tab:inst_compare} pode inferir-se que: ToDo

A tabela \ref{tab:inst_compare} permite fazer uma comparação entre algumas das caracteristicas destes sistemas de instrumentação presentes no núcleo de sistema do \textit{Linux}, segundo os seguintes critérios: metodologia da captura (por traço ou por amostragem), análise dos parâmetros das funções instrumentadas e a necessidade de ter um \textit{deamon} para a recolha de dados provenientes do sistema de monitorização.
Se a necessidade de ter um \textit{deamon} a executar de forma a coligir e organizar os dados, pode penalizar o desempenho do sistema, a possibilidade de analisar os parâmetros das funções instrumentadas é um ponto a favor dos sistemas \textit{KProbes} e do \textit{LKST}.



\section{Transferência de dados}
\label{sect:kernel_user_comm}


Quando se recorre a alguma fonte para a obtenção de dados, não é imprescindível que estes sejam apenas requeridos no sítio onde são adquiridos.
Assim, quando dados que foram obtidos pelo núcleo de modo a serem transferidos para as aplicações 

No intuíto de melhorar a partilha de recursos externos, o controlo dá-se ao nível do núcleo do sistema, pelo que parte das comunicações dos utilizadores com dispositivos externos, é efectuada através do núcleo de sistema.
Não sendo apenas exclusívo dos recursos externos, recursos que sejam partilhados por mais que um processo, em geral são partilhados através do núcleo.
Desta forma é necessário existirem modos de comunicação / transferência de dados entre o núcleo e os processos, por isso existem diversos sistemas de ficheiros virtuais que permitem o controlo e a disponibilização aos processos dos dados adequados.

%Incluir por aqui a informação de mmaps, ring buffers e afins ....
% colocar a parte interna e verificar o mmap que tb faz parte do utilizador
% verificar o mmap da parte de utilizador
%texto explicativo de interno e externo 
\subsection{Técnicas de transferência de dados}

Devido há necessidade de transferir informações entre diferentes \textit{buffers} dentro do núcleo de sistema, foram desenvolvidas técnicas tendo sempre como referência a minimização da sobrecarga.
De entre as diferentes técnicas de transferência interna de informação ao núcleo do sistema, merecem especial relevo:

\paragraph*{\textit{MMAP} - }

Esta técnica é implementada utilizando páginas de memória partilhadas, reduzindo as transferências e gastos de memória, proporciona a possibilidade de mapear um canal para memória potenciando assim, a partilha de dados não só entre diferentes processos como igualmente entre os processos e o núcleo, que necessitem de aceder aos dados do mesmo canal.
A partilha de dados de \textit{IO} é uma vertente que tem sido objecto de desenvolvimento, de forma a aumentar o desempenho, porquanto permite a partilha de dados entre um ou mais programas, e o núcleo de operação.
Esta partilha evita a necessidade de copiar dados dos espaços de endereçamento do núcleo para o do utilizador e vice versa.

\paragraph*{Zero Copy - }

Esta técnica de transferência de dados sem que existam cópias dos \textit{buffers} pertencentes ao núcleo de sistema e ao espaço de utilizador, permite que os dados sejam partilhados por diferentes entidades, sem necessidade de criação de novos \textit{buffers} e cópias de dados, uma vez que apenas são passadas as referências.

\paragraph*{Ring Buffers - }

Esta técnica consiste num aproveitamento dos recursos já alocados, mas que se tornaram desnecessários, estando desta forma disponíveis para nova utilização.
Os \textit{Ring Buffers} são utilizados tendo presente a relação custo / benefício, isto é, quando o peso da criação e destruição de elementos é comparativamente superior à reutilização dos recursos já alocados.
É igualmente utilizada em situações de \textit{"produtor-consumidor"}, ou seja, quando é necessário manter a ordem dos elementos.


\subsection{Interface do sistema com os processos}
% {\color{red}
% \paragraph*{}
% INDICAR QUAIS OS SISTEMAS QUE OS UTILIZAM
% 
% DISTINÇÂO ENTRE OS DIFERENTES SISTEMAS
% }

Devido à necessidade de análise de estruturas e dados do núcleo de sistema, foram criados diferentes subsistemas com vista à sua satisfação.
Um destes subsistemas é o \textit{ProcFs}, que existe no núcleo de sistema do \textit{Linux} desde as primeiras versões.
Outros como o \textit{DebugFs} ou o \textit{RelayFs} são mais recentes e com novas abordagens.
%diferentes abordagens e o pq de ter de existirem estas formas

\paragraph*{}
De forma a obter informações relativas a estruturas dentro do núcleo de sistema, foram referênciados os seguintes sistemas de comunicação entre o utilizador e o núcleo:

\paragraph*{ProcFs - }\label{cap:ProcFs_overview}

Desenvolvido para obter informações relativas aos processos tem sido utilizado desde as primeiras versões do núcleo de sistema do \textit{Linux}.
Apesar de novos sistemas como o \textit{SysFs} terem sido criados, continua a ser extensivamente utilizado pelas aplicações, pois este contém informações disponíveis para o nível utilizador, sobre estruturas e dados dos processos localizadas no núcleo.
Esta é uma das \textit{API's} de comunicação, entre o núcleo e as aplicações, mais utilizadas, não obstante ter crescido de forma desorganizada.

\paragraph*{SysFs - }\label{cap:SysFs_overview}

Este sistema de ficheiros virtual foi desenvolvido para colmatar algumas deficiências encontradas no \textit{ProcFs}.
Estes problemas situam-se basicamente na forma desorganizada como a quantidade de informação disponibilizada está distribuída sobre o \textit{ProcFs}.
Este novo sistema de ficheiros virtual, evidencia restrições na disponibilização das informações, uma vez que apenas é possível visualizar e modificar um \textit{KObject} por ficheiro.
Esta limitação conduziu a que outros sistemas de ficheiros virtuais, nomeadamente o \textit{DebugFs} e o \textit{RelayFs}, fizessem a sua aparição com vista a colmatar esta situação.

\paragraph*{DebugFs - }\label{cap:DebugFs_overview}

Este sistema foi essencialmente criado para ultrapassar as dificuldades sentidas pelos programadores, na utilização de um sistema de ficheiros tão restritivo como o \textit{SysFs}.
Apesar de já existirem dois sistemas de ficheiros virtuais, o \textit{ProcFs} e o \textit{SysFs}, este tentou colmatar os problemas que se apresentavam, não obstante não se mostrar tão estruturado como o \textit{SysFs}, tem melhor organização de dados que o \textit{ProcFs}.

O sistema de instrumentação do núcleo de sistema \textit{Linux}, \textit{KProbes}, utiliza este sistema de ficheiros virtual, de forma a apresentar os pontos onde existe instrumentação no núcleo de sistema.

\paragraph*{RelayFs - }\label{cap:RelayFs_overview}

Este sistema de ficheiros virtual foi desenvolvido tendo em mente a transferência de grandes quantidades de dados entre o núcleo de sistema e o espaço de utilizador.
O \textit{RelayFs} responde a esta exigência, fazendo uso de novas primitivas onde são mais reduzidas as zonas de controlo de concorrência\cite{Donovan2007,To03relayfs:an}.

\paragraph*{NetLink - }\label{cap:NetLink_overview}
O \textit{NetLink} utiliza um método de comunicação baseado em \textit{sockets}, para estabelecer a comunicação entre o núcleo de sistema e os processos, em nível utilizador. 
 Tendo como abstracção os \textit{sockets}, este sistema tem igualmente a possibilidade de enviar dados para múltiplos processos, devido à utilização das primitivas de envio colectivo (\textit{Multicast}).
% \todo{Explicar melhor o NetLink}
 É com base no \textit{NetLink}, que a comunicação entre processos dentro da mesma máquina (\textit{IPC}) é implementada.
%Isto ja e novo
 A comunicação com diferentes partes do subsistema de rede é efectuada recorrendo a este sistema de \textit{sockets}.


\subsection{Comparação entre sistemas de transferência de dados}

\paragraph*{}
Como se pode verificar através da tabela \ref{tab:transf_compare}, que compara a estruturação dos dados de cada Sistema, com o volume de dados que é possível transferir, o \textit{RelayFs} e o \textit{NetLink} são os dois sistemas de comunicação que, não tendo estruturação fixa dos dados, conseguem transferir um volume superior de dados, comparativamente com os restantes, objecto da análise.
%Se limitarmos a análise comparativa aos sistemas \textit{RelayFs} e \textit{NetLink}, constatamos que o volume de dados que é possível transferir pelo primeiro é superior ao verificado no \textit{NetLink}.

% \todo{Corrigir esta tabela}
\begin{table}[!htbp]
\begin{center}
\caption{Tabela Comparativa de transferência de dados entre processos e núcleo de sistema}
\begin{tabular}{|l||c|c|}
\hline
Sistema & Estruturação de Dados & Volume de dados \\
\hline
ProcFs & Com & Reduzido \\
\hline
SysFs & Com & Reduzido \\
\hline
DebugFs & Com & Reduzido \\
\hline
RelayFs & Sem & Bastante Elevado \\
\hline
NetLink & Sem & Elevado \\
\hline
\end{tabular}

\label{tab:transf_compare}
\end{center}
\end{table}
 
\section{Captura de tráfego de um processo especifico}
\label{sect:outras_abordagens}

A captura do tráfego, respeitante a um processo genérico, foi alvo de estudo em \cite{1688981} e em \cite{Farruca:2009}, esta última objecto de uma dissertação de mestrado.

No primeiro trabalho, foi desenvolvido um sistema de captura de pacotes de um determinado processo, utilizando um módulo no núcleo de sistema que intercepta e captura os pacotes do processo.

Este sistema é constituido por três componentes essenciais, uma dentro do núcleo de sistema e duas em nível utilizador.
Na realização do trabalho, foi utilizada a ferramenta \textit{KProbes} para a monitorização de algumas funções do núcleo de sistema \textit{Linux}, de forma a conhecer quais os portos que vão ser utilizados por uma determinada aplicação.
Logo que obtida, a informação é enviada para um processo em nível utilizador que tem o registo de todos os portos que estão a ser utilizados pela aplicação objecto de monitorização.
Se esse porto não estiver a ser monitorizado, essa informação é passada a outro processo que utiliza a biblioteca \textit{PCap} de forma a capturar o tráfego existente nesse porto.


\begin{figure}[h!]
       \centering
       \includegraphics[height=2in]{captura_kprobes_paper}
       \caption{Arquitectura da monitorização de tráfego \cite{1688981}}
	\label{fig:paper_capture_kprobes}
\end{figure}


Analisando a arquitectura de monitorização de tráfego representada na figura~\ref{fig:paper_capture_kprobes}, o ACAP\_Collector e o ACAP\_Capturer, estão em nível utilizador, de onde se infere que o desempenho desta ferramenta é passível de ser aumentado, caso esta seja completamente implementada dentro do núcleo de sistema de operação.

Relativamente ao segundo trabalho, foram implementadas duas abordagens: uma com monitorização da aplicação e outra através de informações pertencentes ao núcleo do sistema de operação.
No que à primeira diz respeito, a monitorização efectuada processou-se através da interceptação das chamadas à bibiloteca \textit{LibC}, para a utilização de \textit{sockets}, criando uma bibiloteca partilhada com a mesma sintaxe das chamadas que são utilizadas.
A opção pela utilização deste método, implica definir a variável de ambiente \textit{LD\_PRELOAD}, de forma a operar esta intercepção.
Como esta biblioteca está em nível utilizador, mostra-se necessário capturar todos os pacotes e apenas em nível utilizador visualizar o tráfego respeitante ao processo.
Esta obrigatoriedade, de capturar todos os pacotes, pode constituir uma tarefa com elevado grau de perturbação do sistema.

No que à segunda abordagem se refere, o método de monitorização utilizado baseou-se na consulta efectuada de forma regular com intervalos reduzidos, dos dados referentes aos portos de comunicação, utilizados pela aplicação, que são exportados pelo núcleo através do \textit{ProcFs}.
Esta forma de monitorização consome demasiados recursos e não se mostra totalmente fiável, na medida em que quanto menor o intervalo de tempo utilizado, maior é a perturbação apresentada pelo sistema.

O dinamismo das aplicações, nomeadamente das aplicações multimédia, deu origem a diversos estudos sobre a forma de monitorização de rede, que estas necessitam.
Estas aplicações utilizam diversos fluxos de dados, designadamente de transmissão e de recepção.
Em geral, as aplicações multimédia, com base na \textit{internet} utilizam uma metodologia cliente/servidor, onde o servidor aguarda pedidos do cliente num determinado porto.
O cliente, conhecendo antecipadamente este porto, liga-se.
A partir deste ponto, iniciam-se trocas de informações, que irão originar a troca de portos dinâmicos e posteriormente o processo de transmissão/recepção de dados multimédia.

As aplicações multimédia assentes na \textit{Internet} são, apenas, um exemplo de aplicações com diversos fluxos, em que as portas de comunicação entre as aplicações, são negociadas dinamicamente.

Como o referido em \ref{sect:LibPcap}, a captura de pacotes é definida em filtros estáticos e para capturar este tipo de tráfego, é necessário modificar os filtros definidos, de modo a acompanhar o protocolo.
Esta forma de captura mostra-se bastante ineficaz, o que motivou a que fossem estudadas algumas alternativas, tendo em vista a correcção desta situação.
Os projectos \textit{mmdump}\cite{505678}, %\textit{Fairly Fast Packet Filters (FFPF)}\cite{1251278} 
e \textit{Swift}\cite{1387609} são dois destes casos estudados, que merecem especial relevância e que adiante se analisam:

\paragraph*{MMDump - } É uma ferramenta de monitorização de protocolos multimédia com suporte na rede.
Esta aplicação tem como base o \textit{tcpdump}, sendo a captura de pacotes efectuada através da utilização de filtros.
Para determinar os portos a obter, é necessário analisar o conteúdo dos pacotes direccionados a portos específicos e, a partir destes é possível identificar os novos portos negociados dinamicamente pela aplicação, para proceder à alteração dos filtros a aplicar.
Como a alteração, que é constituída pela cópia do novo filtro para o núcleo e verificação de segurança, de forma a validá-lo, é um processo demorado, é necessário reduzir este tempo, com o objectivo de ter uma aplicação que consiga minimizar o grau de perturbação no sistema.

Na alteração do filtro, foi verificado que existe um certo padrão, que consiste em pré-estabelecer uma parte comum a ser adicionada ao filtro, e apenas alterar a parte referente aos portos.

Esta forma de monitorização é muito específica, pelo que é imprescindível todo o protocolo interno de comunicação.
Assim, para cada novo protocolo a monitorizar, é necessário acrescentar um novo módulo com a interpretação desse protocolo.

% \paragraph*{\textit{Fairly Fast Packet Filter} (FFPF)}

\paragraph*{\textit{Swift} - }
É uma ferramenta de criação de filtros, cujo principal objectivo é a melhoria do desempenho da utilização destes, na captura do tráfego de rede.
Nesta ferramenta, foi avaliado o tempo de alteração dos filtros, utilizando o \textit{Linux Socket Filtering}, pois estes são os filtros de referência no sistema de operação \textit{Linux}.
A aplicação destes filtros a partir da biblioteca \textit{PCap} compreende três fases: cópia do filtro definido em nível utilizador para o núcleo de sistema, verificação de segurança, e aplicação do filtro.
De forma a diminuir a latência de actualização dos filtros, foi criada uma especificação de modo a que estes não necessitassem de ser analisados relativamente à segurança, visto que a própria linguagem garante as propriedades de segurança necessárias.
Com este novo \textit{instruction set} e, sem necessidade de verificação, foi reduzida a latência de actualização dos filtros, o que conduziu a um aumento de desempenho na utilização de filtros dinâmicos.


%\section{Conclusão}





%\section{Filtragem de pacotes de um processo através do \textit{Netfilter}}

%O \textit{NetFilter} é o sistema de filtragem de pacotes do núcleo do \textit{Linux} que irá ser apresentado na secção \ref{}.
%Foi implementado um módulo no núcleo utilizando o \textit{NetFilter} que filtra os pacotes pertencentes a um processo ou utilizador.
%Este sistema, verifica relativamente a cada pacote que é recebido ou enviado, se este faz parte do processo ou processos pertencentes a um utilizador, verificando canal a canal se o identificador do canal do pacote é igual ao canal do processo.


%Falta falar do ipt\_owner do iptables entre outros ....

\section{Conclusão}
\label{sec:segundo:conclusion}
Como se pode observar neste capítulo, existe a possibilidade de melhorar a monitorização de rede do \textit{Linux}.
O mecanismo de instrumentação genérico do \textit{Linux}, \textit{KProbes}, permite que se efectuem análises no núcleo de modo generalista, o que para obter as interacções dos processos com as interfaces de rede sem que se assista à instrumentação do código dos processos e com baixa sobrecarga será um sistema de instrumentação dinâmico a ter em conta para o desenvolvimento de um mecanismo de monitorização genérico de rede de um processo.

Sistema de \textit{logging}, são por vezes um peso demasiado elevado e por isso utilizam mecanismos para fazer face a este problema de transporte da informação dos dados do núcleo para o nível utilizador o mais eficiente possível.


Quaisquer das soluções apresentadas tem limitações e defeitos ...
