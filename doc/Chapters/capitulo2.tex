\chapter{Trabalho relacionado}
\label{cap:trabrelacionado}
 %Este capítulo deve conter uma síntese inicial de trabalho relacionado 
%(como resumo de estado da arte) e com foco nos objectivos e contribuições da
%dissertação. 
%O capítulo deve demonstrar que o aluno procedeu e uma recolha bibliográfica para
%análise, tratamento e classificação preliminar, devendo esta ser suficientemente
%representativa das leituras preparatórias para o prosseguimento da elaboração da 
%dissertação. Esta síntese deve ser apresentada com as respectivas referências 
%bibliográficas (correctamente apresentadas na Bibliografia).

%Usar no capítulo fonte times-roman 12 com um espaçamento e meio, esperando-se
%uma dimensão indicativa de cerca de 20 páginas.
 
% \indent \indent Ferramentas para captura de pacotes de rede ao nível do sistema de operação não
% têm sido muito desenvolvidas.
% 
% O trabalho nesta área tem centrado-se no aumento da performance da captura dos
% pacotes que transitam na rede.\cite{Deri2004}
% 
% Duas das formas que irei abordar serão a utilização de instrumentação dinâmica 
% e o desenvolvimento de um filtro para a libpcap dentro do kernel. Ambos as formas 
% irão ser abordadas de seguida.

% No artigo escrito por Byungjoon Lee, Seong Moon e Youngseok Lee intitulado 
% \textit{Application-specific packet capturing using kernel probes}\cite{Lee2009}
% foi descrito como executaram um sistema de instrumentação para captura de pacotes
% relativos a uma aplicação, o que demonstra que existe a necessidade de capturar 
%o trafego referente apenas uma aplicação para ser efectuado uma análise mais pormenorizada.


\section{Sistemas de monitorização em Linux}\label{sect:instrumentacao_casos_linux}

Como o anteriormente analisado na secção \ref{sect:instrumentation_overview} referente à monitorização, esta secção é dedicada à apresentação das diferentes ferramentas de monitorização do núcleo de sistema do \textit{Gnu Linux} sendo as mais recentemente utilizadas neste sistema de operação.

\subsection{KProbes}\label{sect:KProbes_overview}

O \textit{KProbes} é uma ferramenta de instrumentação dinâmica do núcleo de sistema do \textit{Gnu Linux}.
A \textit{API} desta ferramenta permite que outras aplicações de mais alto nível, como o \textit{DProbes} ou o \textit{SystemTap} possam aceder às suas funcionalidades.
Esta encontra-se na versão principal do núcleo do sistema \textit{Linux} desde a versão 2.6.9, o que indica tratar-se de uma ferramenta bastante estável\cite{kernel_debug_printk_on_fly,KProbesSite}.


Para se obterem informações sobre as funções ou instruções que estão a ser monitorizadas, o \textit{KProbes} disponibiliza-as por meio do \textit{DebugFs}.

Existem três tipos de instrumentação que podem ser efectuados: \textit{KProbe}, \textit{JProbe} e \textit{KRetProbe}.
Cada um destes três tipos é especifico de uma determinada funcionalidade.

\begin{itemize}
 \item \textbf{KProbe}
% \paragraph*{\textbf{KProbe}}
Utilizando um KProbe pode-se detectar a chamada de funções ou apenas de uma instrução.
Para analisar apenas uma instrução, tem de ser indicado o \textit{offset} relativamente à distância ao inicio da função instrumentada.
A indicação da função a instrumentar, pode ser definida recorrendo ao seu nome ou ao endereço de memória.
Múltiplos \textit{KProbe} podem ser definidos para uma mesma função ou instrução.

\item \textbf{JProbe}
% \paragraph*{\textbf{JProbe}}
Um \textit{JProbe} destina-se a analisar os parâmetros, da função a instrumentar.
Quando é declarado um \textit{JProbe} a função de \textit{handler} tem de ter conter os mesmos tipos de argumentos que a função que se destina a ser instrumentada, de forma a serem passíveis de serem monitorizadas.
 

 \item \textbf{KRetProbe}
% \paragraph*{\textbf{KretProbe}}
Este tipo de análise tem como objectivo obter o valor de retorno da função que se pretende analisar.
Para efectuar esta operação é utilizada a técnica do trampolim~\cite{Hollingsworth94dynamicprogram}, uma vez que uma função pode terminar em pontos diversos.


\end{itemize}

Para utilizar o \textit{KProbes} é necessário criar um módulo para o núcleo do sistema de operação, com informações relativas às rotinas a instrumentar.
Para além destas o módulo tem de conter igualmente os \textit{handlers} de análise, assim como outros parâmetros necessários à realização da instrumentação.
Uma vez que os módulos são escritos em linguagem C ou \textit{assembly}, foram desenvolvidas as ferramentas, \textit{DProbes} e \textit{SystemTap}.
Estas novas ferramentas de mais alto nível ajudam no desenvolvimento de \textit{scripts}, simplificando e melhorando a segurança na utilização desta ferramenta de instrumentação (\textit{KProbes}).

Quando o módulo é inserido no núcleo de sistema, o registo dos \textit{handlers} das funções a serem instrumentadas é efectuado de forma atómica.
A execução do \textit{KProbes} não utiliza nenhum \textit{mutex} ou outra forma de controlo de concorrência, apenas funciona com a preempção desligada.
Dependendo da arquitectura, os \textit{handlers} podem também executar com as interrupções desligadas.

A instrumentação processa-se pela subsituição dos endereços das funções a serem analisadas, por interrupções (utilizando neste caso o \textit{int 3}).
Quando possível o \textit{KProbes} utiliza instruções do processador especializadas no \textit{debug} de forma a minimizar o grau de perturbação.

Apesar de ser possível instrumentar praticamente todo o núcleo do sistema de operação, existem algumas situações que podem requerer alguma perícia na forma como são tratadas.
Quando o compilador realiza substituição de funções por código \textit{inline}, as instruções que anteriormente estavam dentro da função passam a fazer parte do ponto onde foram substituídas, deixando de existir um ponto de entrada na função.
Assim sendo, a função deixa de existir, impossibilitando a instrumentação destas funções.

Existe uma nova optimização do \textit{KProbes} nas últimas versões do núcleo de operação, nomeadamente nas versões 2.6.32 e 2.6.33.
% Esta optimização consiste em utilizar a instrução \textit{jmp} em vez da interrupção \textit{int3}, mais pesada, 
% mas estas substituição não pode ser efectuada em todas as situações. (ME) falta descrever ou não o pq de ser mais pesada

%Falta ver a estatisticas que estão no ficheiro KProbes.txt na documentação do kernel, 
%onde tem as estatisticas dos custos de cada tipo

\subsubsection{DProbes}\label{cap:Dprobe_overview}

%Esta ferramenta também foi desenvolvida pela IBM estando agora como um projecto no site sourceforge.net .

O \textit{DProbes} utiliza o \textit{KProbes} como suporte para efectuar a instrumentação dinâmica do núcleo de sistema.
Como a criação de pontos de análise é escrito em linguagem C ou \textit{assembly}, foi desenvolvida uma linguagem de mais alto nível de forma a simplificar  a utilização desta aplicação.

Após os dados terem sido obtidos, estes podem ser transferidos para um ficheiro, para o \textit{daemon logging} do núcleo de sistema, ou para uma porta série.
Existe igualmente a opção de interoperabilidade com o \textit{Linux Trace Toolkit}\cite{:DProbes}.

\subsubsection{SystemTap}\label{cap:Systemtap_overview}
% Ainda tem de ser bem pensado o que escrever
O \textit{SystemTap} é uma ferramenta que possibilita o desenvolvimento de módulos para o \textit{KProbes}, utilizando uma linguagem específica, de forma a ser segura e fácil de trabalhar.

%A facilidade no desenvolvimento de scripts (tapsets) utilizando a linguagem de scripting criada para o efeito.

% O sistema utilizado pelo SystemTap para passar informações ao processo em espaço utilizador é o replayFs.
% para além de ter encontrado instruções neste sentido, a obtenção do strace veio confirmar estes dados

Uma vez que os dados gerados estão no espaço de endereçamento de memória do núcleo, e o programa que os analisará se situa no espaço de endereçamento do utilizador, é necessário efectuar uma transferência de dados de um para outro espaço.
O \textit{SystemTap} efectua esta transferência, recorrendo à utilização do sistema de ficheiros \textit{ReplayFs}, onde é possível escrever de forma rápida, sem comprometer a segurança do sistema.\cite{Donovan2007,Jones2009}

Apesar de no pacote de aplicações desta ferramenta existir um visualizador gráfico de dados, recolhidos pelo \textit{SystemTap}, esta só consegue analisar os \textit{TapSets} pré-definidos no \textit{SystemTap}, para ultrapassar esta limitação, novas ferramentas estão a ser desenvolvidas.
Uma destas ferramentas designada por \textit{bootlimn}, está actualmente a ser desenvolvida no \textit{Google Summer of Code}, com o objectivo de utilizar o \textit{SystemTap} para recolher informações sobre o arranque do sistema, agregando estes dados no formato \textit{XML}.
Os dados recolhidos permitem visualizações gráficas do processo de inicialização do sistema, bem como da utilização de disco e \textit{CPU}.
Outro projecto conhecido como \textbf{Systemtap GUI}, que engloba o \textbf{System Tap Editor Plug-in} para a ferramenta Eclipse, é um ambiente onde podem ser analisados e visualizados os dados recolhidos pelo \textit{SystemTap}.
O \textit{System Tap Editor Plug-in} é um \textit{plug-in} para a ferramenta de desenvolvimento \textit{Eclipse}, de modo a ajudar no desenvolvimento dos \textit{TapSets} para o \textit{SystemTap}.

O \textit{SystemTap} actualmente está a ser desenvolvido por empresas de reconhecido mérito internacional, nomeadamente a \textit{Red Hat}, a \textit{IBM}, a \textit{Hitachi} e a \textit{Oracle}.

\subsection{Linux Trace ToolKit}\label{cap:linux_trace_toolkit_overview}

% O Linux Trace Toolkit é uma ferramenta de ``tracing''
% Utiliza o Klog com repositorio da informação obtida do kernel.
O \textit{Linux Trace ToolKit} é uma ferramenta um pouco mais antiga que o \textit{KProbes}, constituída por quatro componentes: o \textit{Kernel Patch}, pelo o \textit{Kernel Module} o \textit{Trace Daemon} e o \textit{Data Decoder}, foi substituída pelo \textit{Linux Trace Toolkit New Generation} que se apresenta em seguida.

\subparagraph{Linux Trace Toolkit New Generation}\label{cap:lttng_overview}

% Nesta versão a comunicação entre o kernel e aplicação em user space é efectuada utilizando o relayfs.
% O RelayFs é um sistema de ficheiros para comunicação entre o código dentro e fora do núcleo de operação.

Representa uma evolução do \textit{LTT (Linux Trance ToolKit)}, e permite colaborar com ferramentas como o \textit{KProbes}, o \textit{Tracepoints}\cite{Mathieu2009} e \textit{Linux Kernel Markers}\cite{Mathieu2009}.
As ferramentas \textit{Tracepoints} e Linux \textit{Kernel Markers} fazem parte da instrumentação estática pertencente ao núcleo de sistema \textit{Gnu Linux}.

A transferência dos dados do núcleo de sistema para a aplicação, é efectuada utilizando o \textit{RelayFs}.

%A utilização desta ferramenta em sistemas de tempo real é um bom indicador da sua performance.

\subparagraph{Linux Trace Toolkit Viewer}\label{cap:lttv_overview}
O \textit{Linux Trace Toolkit Viewer (LTTV)} é um projecto desenvolvido em paralelo com o \textit{LTT} e \textit{LTTng} de forma a possibilitar uma análise visual dos dados recolhidos por estas aplicações.
Esta ferramenta possibilita igualmente realizar um traço de execução, uma vez que os dados recolhidos contêm uma estampilha temporal do momento em que foram obtidos.


\subsection{Linux Kernel State Tracer}
% Linux Kernel State Tracer(LKST) records information as trace data about events in the Linux Kernel. It records various events like process context switch, send signal, exception, memory allocation, send packet, and so on. 

O \textit{Linux Kernel State Tracer(LKST)} obtém informações referentes ao núcleo de sistema de forma a criar um traço de execução, e consegue capturar diferentes eventos como trocas de contexto, envio de sinais, alocação de memória, transmissão de pacotes, etc.

% a\subparagraph{DJProbe}
\label{cap:djprobe}
  % Este sistema é mais leve devido à forma como é feito o ``trap'' pois não usa o int 3
% Duvidas na forma como é controlado o sistema na presença de processadores maquinas com multiplos processadores.
% Não utiliza o int 3 para fazer o trap por isso segundo o artigo fica mais leve que o KProbe e o JProbe.
% DJProbe  quer dizer Direct Jump Probe faz um jmp e não usa o int 3.
Actualmente está a ser desenvolvido como um subprojecto do \textit{Linux Kernel Stace Tracer} designado por \textit{Direct Jump Probe}.
Esta ferramenta de instrumentação é uma optimização à utilização do \textit{trap int3}, presente em alguns processadores, e que pode trabalhar em conjunto com o \textit{KProbes} \ref{sect:KProbes_overview}.
Esta optimização pode ser verificada na comparação efectuada no relatório\cite{Hiramatsu2005}.
 
\subsection{OProfile}\label{cap:Oprofile_overview}
Todas ferramentas anteriores mencionadas utilizem mecanismos para formar um traço de execução, este difere neste facto.
Em vez de a cada evento utilizar uma função para obter os dados, apenas a utiliza decorridos um certo número de eventos.
O recurso a este critério permite ao \textit{OProfile} ser mais eficiente, uma vez que nem sempre é necessário o universo dos eventos que as ferramentas de monitorização capturam, mas tão somente uma amostra.
Esta é uma forma criada de modo ao \textit{OProfile} tornar-se mais eficiente, uma vez que nem sempre são necessários todos os eventos que as ferramentas de instrumentação capturam.
Deste modo ao utilizar a amostragem, o \textit{OProfile}, benficia de um menor grau de perturbação no sistema\cite{Will:TuninProgrOProf}.
% ser menos perturbador do sistema.
% it uses data sampling ... the others don't

% outra abordagem 

\subsection{Comparação entre os diferentes sistemas de instrumentação}
% \todo{completar esta tabela}
\begin{table}[h!]
\begin{center}
\caption{Tabela Comparativa dos sistemas de instrumentação}
\label{tab:inst_compare}
\begin{tabular}{|l||c|c|c|}
\hline
Instrumentação & Amostragem / Traço & Análise de Parâmetros & Deamon \\
\hline
KProbes & Traço & Permite & Não necessita \\
\hline
LTT & Traço & Não permite & Necessita \\
\hline
LKST & Traço & Permite & Não necessita \\
\hline
OProfile & Amostragem & Não permite & Necessita \\
\hline
\end{tabular}
\end{center}
\end{table}

Da observação da tabela \ref{tab:inst_compare} pode inferir-se que: TODO

A tabela \ref{tab:inst_compare} permite fazer uma comparação entre alguns dos atributos destes sistemas de instrumentação presentes no núcleo de sistema do \textit{Linux}.
Os diferentes sistemas de instrumentação dinâmica do núcleo do \textit{Linux} segundo os seguintes critérios: metodologia da captura (por traço ou por amostragem), análise dos parâmetros das funções instrumentadas e a necessidade de ter um \textit{deamon} de recolha de dados provenientes do sistema de monitorização.
A necessidade de ter um \textit{deamon} a executar de forma de coligir e organizar os dados pode penalizar a performance do sistema.
A possibilidade de analisar os parâmetros das funções instrumentadas é um ponto a favor do sistema. 

\section{Transferência de dados}
\label{sect:kernel_user_comm}

Quando se recorre a alguma fonte para a obtenção de dados, não é imprescindível que estes sejam requeridos no sítio onde são capturados.
Assim foram criados dois modos de transferência de dados:as internas e as externas.
No intuíto de melhorar a partilha dos recursos externos, o controlo dá-se ao nível do núcleo do sistema, pelo que parte das comunicações dos utilizadores com dispositivos externos, é efectuada através do núcleo de sistema.

%Incluir por aqui a informação de mmaps, ring buffers e afins ....
% colocar a parte interna e verificar o mmap que tb faz parte do utilizador
% verificar o mmap da parte de utilizador
%texto explicativo de interno e externo 
\subsection{Interna ao sistema}

Devido há necessidade de transferir informações entre diferentes \textit{buffers} dentro do núcleo de sistema, foram desenvolvidas novas técnicas tendo sempre como referência a minimização da sobrecarga.

De entre as diferentes técnicas de transferência interna de informação ao núcleo do sistema, merecem especial relevo:

\paragraph*{\textit{MMAP}}
\label{par:MMAP_overview}


Esta técnica é implementada utilizando páginas de memória a pedido, reduzindo as transferências e gastos de memória, proporciona a possibilidade de mapear um ficheiro para memória potenciando assim, a partilha de dados entre diferentes processos que necessitem aceder ao mesmo ficheiro.
A possibilidade de partilha de dados de \textit{IO} é uma vertente que pode ser objecto de desenvolvimento, de forma a aumentar o desempenho, porquanto permite a partilha de dados entre um ou mais programas, e o núcleo de operação.

\paragraph*{Zero Copy}
\label{par:zero_copy_overview}

Esta técnica de transferência de dados sem que existam cópias dos \textit{buffers} pertencentes ao núcleo de sistema e ao espaço de utilizador, permite que os dados sejam partilhados por diferentes entidades, sem a necessidade de criação de novos \textit{buffers} e cópias de dados, uma vez que apenas são passadas as referências.

\paragraph*{Ring Buffers}
\label{c}
Esta técnica consiste num aproveitamento dos recursos já alocados, mas que se tornaram desnecessários, estando desta forma passíveis de nova utilização.
Os \textit{Ring Buffers} são utilizados tendo presente a relação custo / benefício, isto é, quando o peso da criação de novos elementos é superior compartivamente com os recursos já alocados.
É igualmente utilizada em situações de \textit{"produtor-consumidor"}, ou seja, quando é necessário manter a ordem dos elementos.

\paragraph*{NAPI - New API}
\label{par:NAPI}
%VERIFICAR a origem do NAPI 

Foi criada uma nova \textit{API} (\textit{Application Program Interface}) de atendimento de interrupções do processador, oriundos das interfaces de rede, com o objectivo de aumentar o desempenho da utilização de rede elevado débito.
Esta nova \textit{API} permite desligar a atenção do processador a novas interrupções, oriundas da interface de rede, durante um certo período de tempo.

Este tempo foi definido de forma a que não se verifiquem situações de elevada latência na chegada dos pacotes às aplicações.
A forma anterior de recepção de pacotes, era efectuada de forma a atender uma interrupção por cada pacote que chegava à interface de rede, gerando assim demasiada sobrecarga no sistema.
Actualmente a arquitectura de rede, está balanceada de forma a mudar o modo de atendimento de interrupções para NAPI, caso existam demasiadas interrupções por unidade de tempo.~\cite{administrator:napi}.

Utilizando esta nova \textit{API}, é possível explorar um escalonamento mais eficiente das interrupções em situações de intensa actividade do processador.
O \textit{NAPI} apenas pode ser aplicado nos caso em que os controladores das interfaces de rede estejam preparados para utilizar alguma forma de mitigação da interrupção, caso contrário esta \textit{API} não é aplicada.

\subsection{Com o exterior do sistema}
% {\color{red}
% \paragraph*{}
% INDICAR QUAIS OS SISTEMAS QUE OS UTILIZAM
% 
% DISTINÇÂO ENTRE OS DIFERENTES SISTEMAS
% }

Devido à necessidade de análise de estruturas e dados do núcleo de sistema, foram criados diferentes subsistemas com vista à sua satisfação.
Um destes subsistemas é o \textit{ProcFs}, que existe no núcleo de sistema do \textit{Linux} desde as primeiras versões.
Outros como o \textit{DebugFs} ou o \textit{RelayFs} são mais recentes e com novas abordagens.
%diferentes abordagens e o pq de ter de existirem estas formas

\paragraph*{}
De forma a obter informações relativas a estruturas dentro do núcleo de sistema foram referênciados os seguintes sistemas de comunicação entre o utilizador e o núcleo, a saber:

\paragraph*{ProcFs}\label{cap:ProcFs_overview}

Desenvolvido para obter informações relativas aos processos tem sido utilizado desde as primeiras versões do núcleo de sistema do \textit{Linux}.
Apesar de novos subsistemas como o \textit{SysFs} terem sido criados, é ainda utilizado por algumas aplicações.

\paragraph*{SysFs}\label{cap:SysFs_overview}

Este sistema de ficheiros virtual foi desenvolvido para colmatar algumas deficiências encontradas no \textit{ProcFs}(secção \ref{cap:ProcFs_overview}).
Estes problemas situam-se basicamente na forma como a quantidade de informação disponibilizada está distribuída sobre o \textit{ProcFs}.
Este novo sistema de ficheiros virtual evidencia algumas restrições designadamente a forma como são disponibilizados os dados do núcleo de sistema.
Esta limitação conduziu a que outros sistemas de ficheiros virtuais, nomeadamente o \textit{DebugFs} e o \textit{RelayFs} fizessem a sua aparição.

\paragraph*{DebugFs}\label{cap:DebugFs_overview}

Este sistema foi essencialmente criado a pensar nas necessidades sentidas pelos programadores.
Apesar de já existirem dois sistemas de ficheiros virtuais, o \textit{ProcFs} e o \textit{SysFs}, este tentou colmatar os problemas que se apresentavam, não obstante se mostrar tão estruturado como o \textit{SysFs}, ou com melhor organização de dados que o \textit{ProcFs}.

O sistema de instrumentação do núcleo de sistema \textit{Linux}, \textit{KProbes}, utiliza este sistema de ficheiros virtual de forma a apresentar os pontos onde existe instrumentação no núcleo de sistema.

\paragraph*{RelayFs}\label{cap:RelayFs_overview}

Este sistema de ficheiros virtual foi desenvolvido tendo em mente a transferência de grandes quantidades de dados entre o núcleo de sistema e o espaço de utilizador.
O \textit{RelayFs} permite um aumento de transferências de dados entre o núcleo de sistema e o processo em nível utilizador, fazendo uso de novas primitivas onde são mais reduzidas as zonas de controlo de concorrência\cite{Donovan2007}.

\paragraph*{NetLink}\label{cap:NetLink_overview}
O \textit{NetLink} utiliza uma forma de comunicação baseada em \textit{sockets} para estabelecer a comunicação entre o núcleo de sistema e os processos em nível utilizador. 
 Tendo como abstracção os \textit{sockets} este sistema tem igualmente a possibilidade de enviar dados para múltiplos processos, devido à utilização das primitivas de envio colectivo (\textit{Multicast}).
% \todo{Explicar melhor o NetLink}
 É com base no \textit{NetLink} que a comunicação entre processos dentro da mesma máquina (\textit{IPC}) é implementada.
%Isto ja e novo
 A comunicação com diferentes partes do subsistema de rede é efectuada recorrendo a este sistema de \textit{sockets}.

%Isto e novo
%\paragraph*{Splice}
%Falar sobre esta chamada ao sistema

%Isto e novo
%\paragraph*{Tee}
%Falar sobre esta chamada ao sistema


% \todo{Corrigir esta tabela}
\begin{table}[h]
\begin{center}

\begin{tabular}{|l||c|c|}
\hline
Sistema & Estruturação de Dados & Volume de dados \\
\hline
ProcFs & Com & Reduzido \\
\hline
SysFs & Com & Reduzido \\
\hline
DebugFs & Com & Reduzido \\
\hline
RelayFs & Sem & Bastante Elevado \\
\hline
NetLink & Sem & Elevado \\
\hline
\end{tabular}
\caption{Tabela Comparativa de transferência de dados entre processos e núcleo de sistema}
\label{tab:transf_compare}
\end{center}
\end{table}

\paragraph*{}
Como se pode verificar através da tabela \ref{tab:transf_compare} que compara a estruturação dos dados de cada Sistema com o volume de dados que é possível transferir.
O \textit{RelayFs} e o \textit{NetLink} são os dois sistemas de comunicação que não tendo estruturação fixa dos dados, conseguem transferir um volume superior de dados, comparativamente com os restantes objecto da análise.
Se limitar-mos a análise comparativa dos sistemas \textit{RelayFs} e \textit{NetLink}, constatamos que o volume de dados que é possível transferir pelo primeiro é superior ao verificado no \textit{NetLink}.

\section{Biblioteca LibPcap}\label{sect:LibPcap}

A monitorização de rede existente no \textit{Gnu Linux} permite capturar os pacotes de rede logo que eles chegam ao controlador de rede.
Assim a biblioteca \textit{LibPcap}\cite{:LibPcap} faz uso desta possibilidade.
Uma das principais características desta biblioteca é a sua \textit{API} de alto nível para a captura de pacotes que é igual em todas as plataformas.
Para filtrar os pacotes indesejados a \textit{LibPcap}, utiliza filtros baseados no \textit{BPF (Berkeley Packet Filtering)}, implementados no núcleo de sistema de modo a que a monitorização se torne mais eficiente.

Em seguida é apresentada a arquitectura da biblioteca \textit{Pcap}.

\subsection {Arquitectura}
\label{sect:architecture_libpcap}
A arquitectura do \textit{Pcap} subdivide-se em duas partes: a biblioteca a nível utilizador, e o módulo no núcleo de sistema composto por \textit{sockets} e filtros que são utilizados na captura.
Como se constata na figura \ref{fig:pcap_architecture} a utilização de filtros é aplicada assim que os pacotes são recebidos.
Este sistema de captura permite que pacotes que não são visíveis às aplicações devido à \textit{firewall} do \textit{Linux} possam ser capturados e analisados pelas ferramentas de monitorização de rede.

\begin{figure}[h]
       \centering
       \includegraphics[height=2in]{pcap_architecture2}
       \caption{Arquitectura do LibPcap}
      \label{fig:pcap_architecture}
\end{figure}

A arquitectura de rede do núcleo de sistema \textit{Linux}, utiliza \textit{socket buffers}, que contêm dados referentes às diferentes camadas da \textit{stack TCP/IP}.
Esta estrutura que dispõe de toda a informação sobre o pacote, a receber pela aplicação, é igualmente utilizada nos sistemas de monitorização em nível utilizador.
A monitorização da rede é efectuada directamente no controlador da interface de rede, utilizando para isso um \textit{socket} \textit{AF\_PACKET}.

\subsubsection{UserLevel}

A biblioteca dinâmica \textit{LibPcap} é utilizada pela generalidade dos programas de captura de pacotes.
Esta biblioteca, como é multi-plataforma, permite ao programador utilizá-la nos principais sistemas de operação, porque a \textit{API} da \textit{LibPcap} é opaca relativamente à implementação, esta sim especifica de cada plataforma.
Para ser possível efectuar a captura de pacotes, o programa tem de especificar qual a interface de rede que quer monitorizar.
Se necessitar de filtrar pacotes, especificará os filtros a utilizar, recorrendo para isso à função \textit{setFilter}, que aplicará o filtro criado anteriormente, através da notação \textit{BPF}.
Após esta inicialização, o programa poderá utilizar \textit{Polling}, de forma a obter os pacotes e analisá-los.

\subsubsection{AF\_PACKET}

O módulo \textit{AF\_PACKET} permite utilizar explicitamente o modo promiscuo, ou seja permite que sejam capturados pacotes que não são destinados à máquina utilizada.
Na versão actual do núcleo de sistema do \textit{Linux} (2.6.32) o módulo \textit{AF\_PACKET} já pode utilizar um sistema de partilha de \textit{buffer} com o espaço de utilizador.
Neste caso cabe ao utilizador definir explicitamente a forma como pretende utilizar o \textit{socket}. 
Para atingir este objectivo o utilizador tem de pedir ao núcleo, uma região de memória, sendo esta, posteriormente indicada como argumento de configuração do novo \textit{socket}.

Como o referido anteriormente, o \textit{AF\_PACKET}, permite a comunicação directa com o controlador da interface de rede, possibilitando capturar os diversos pacotes ainda antes destes poderem ser filtrados pela \textit{firewall}, presente no núcleo de sistema, neste caso o \textit{netfilter}.
Podem ser aplicados filtros aos \textit{sockets} de modo a aumentar a eficiência na captura dos pacotes, excluindo aqueles que são irrelevantes para a monitorização.

Dos filtros em questão merece especial referência:

\subsubsection{Linux Socket Filtering}
O \textit{Linux Socket Filtering} é derivado do \textit{BPF (Berkeley Packet Filtering)} que é o standard de \textit{de facto} para a criação de filtros dentro do núcleo de sistema. 

Este sistema de filtros permite aos os utilizadores com permissões de \textit{Super User}, definir filtros e afectá-los aos \textit{sockets}.
Os filtros definidos são descritos numa linguagem simples, de forma a efectuarem com rapidez a selecção dos pacotes a capturar, rejeitando todos os outros.
Se o filtro for demasiado complexo, não poderá ser aplicado no núcleo, sendo apenas possível aplicá-lo em nível utilizador, perdendo algum desempenho.
A linguagem utilizada para a criação dos filtros é compilada para o \textit{Instruction Set}, definido no \textit{BPF}.
Este \textit{Instruction Set} utiliza operadores lógicos de forma a combinar as regras definidas nos filtros, criando-se apenas um fluxo que pode ser aplicado aos \textit{sockets}.
Para se poder definir uma nova instrução para no \textit{Instruction Set} é necessário alterar o ficheiro \textit{grammar.y}, na entrada correspondente à posição que deverá ocupar na \textit{AST (Abstract Sintax Tree)}, e modificar as funções de criação do novo filtro, quer em modo utilizador quer dentro do núcleo de sistema.
Este desenvolvimento tem de ser efectuado par-a-par, pois a ser efectuado apenas de um lado, ou outro tornar-se-á incompatível.~\cite{Mccanne92thebsd}.

\subsection{Desempenho}
De forma a medir o desempenho da \textit{LibPcap}, é frequente utilizar-se uma métrica que nos permita determinar a percentagem de pacotes que é possível capturar, sem que se verifiquem perdas.
Esta métrica é calculada sabendo o número de pacotes que atravessam um determinado \textit{router ou switch}, e compará-la com o número de pacotes capturados na interface.
Uma variante desta medida de desempenho é combiná-la com o máximo número de regras que é possível aplicar, sem que se assista à perda de pacotes.
É particularmente importante conhecer o número máximo de pacotes capturados ou regras aplicáveis aos filtros, afim de determinar a velocidade máxima expectável de captura.
Quanto mais eficiente for a filtragem, menor o número de pacotes transferidos para as aplicações, o que se traduz numa menor sobrecarga para o sistema aumentando o seu desempenho.

\paragraph{Captura de pacotes com \textit{TimeStamp}}
% como etiquetar os pacotes 
Um dos pontos que pode influenciar negativamente o desempenho da obtenção de pacotes, sem que contudo seja significativo, é a necessidade de colocar nestes uma estampilha temporal, com o tempo da sua chegada ao sistema.
O \textit{LibPcap} pode obter estes dados de duas formas distintas dependo da interface de rede que esteja a ser utilizada.
Se a interface de rede conseguir fornecer a estampilha temporal associada ao pacote, o \textit{LibPcap} pode utilizar este valor, caso contrário será necessário obter a estampilha temporal da chegada do pacote ao sistema.
A forma como a \textit{LibPcap} obtém esta estampilha é através da função \textit{gettimeofday}.

\subsubsection{Implementações que permitem um aumento da taxa de transferência}

Apesar de ser igual \textit{API} existente em diferentes plataformas, o desempenho destas pode variar.
Quando exista pouco tráfego de rede estas diferenças são pouco notórias, mas logo que este se intensifica, estas acentuam-se bastante, como demonstra o estudo \textit{Improving Passive Packet Capture: Beyond Device Polling} \cite{Deri2004}.

Diversos esforços no sentido de aumentar o desempenho da captura de pacotes têm sido efectuados.
Relativamente ao \textit{software}, são conhecidos esforços na utilização da técnica de \textit{mmap}, de forma a reduzir o número de cópias de dados entre as aplicações e o núcleo de sistema.
Igualmente no \textit{hardware}, tem-se assistido a uma evolução no sentido de reduzir as interrupções efectuadas ao cpu, adicionando nas interfaces de rede processadores dedicados às funcionalidades presentes no núcleo, de modo a libertá-lo da execução destas tarefas.

\paragraph*{NAPI}

A utilização desta nova \textit{API} permite diminuir o número de trocas de contexto entre o \textit{device driver} e o núcleo de sistema.
Ao diminuir o número de vezes que é interrompido, o núcleo de sistema de cada vez que atende uma destas interrupções tem de obter um número maior de dados, o que combinado com um sistema de memória partilhada pode aumentar bastante a performance.
Esta técnica está descrita na sub-secção \ref{par:NAPI}

\paragraph*{Packet\_MMAP}

Com base na anterior técnicas de \textit{MMAP} descrita em \ref{par:MMAP_overview} foi criado o \textit{PACKET\_MMAP}, disponível a a partir da versão 1.0.0 da biblioteca do \textit{LibPcap}.
Este módulo permite algumas melhorias em termos de performance, pois foi reduzido o número de cópias efectuadas, e de trocas de contexto face à anterior versão 0.9.8 da biblioteca \textit{LibPcap}.

Para além destas modificações no \textit{Packet\_MMAP} o núcleo de sistema de operação \textit{linux} na sua versão 2.6, passou a contar com a nova \textit{API} de rede (\textit{NAPI}) anteriormente descrita em \ref{par:NAPI}.

Se as interfaces de rede suportarem um mecanismo de mitigação de interrupções, é possível obter resultados ainda melhores, como pode ser visto em \cite{Deri2004}.

% \subsection{Aplicação com base na Lipcap}
% 
% Novas aplicações com base em alterações efectuadas ao LibPcap surgiram. Um exemplo destas foi a aplicação NTOP. Esta utiliza uma versão modificada do LibPcap, onde a captura dos dados é obtida da interface de rede directamente para um \textit{Ring Buffer} partilhado entre a aplicação NTOP e o controlador da interface de rede.\cite{Deri2004}

\paragraph*{PF\_RING}

Este é um novo módulo para o núcleo de sistema, criado com base em duas técnicas \textit{mmap} e \textit{ring\_buffers} anteriormente descritas em \ref{par:MMAP_overview} e \ref{par:MMAP_overview} respectivamente.
Este módulo difere na abordagem utilizada no \textit{Packet\_MMAP}, pois nesta a memória mapeada entre a ferramenta e o controlador da interface, enquanto que no \textit{Packet\_MMAP} a memória é mapeada entre a ferramenta e um \textit{buffer} externo ao controlador da interface, mas interno ao núcleo de sistema.
Esta abordagem permite que os dados fiquem disponíveis à aplicação directamente sem que exista cópia dos dados do \textit{buffer} do controlador para um \textit{buffer} partilhado entre a ferramenta e o núcleo\cite{:PF_RING}.
 
\paragraph*{PF\_RING com DNA (Direct Nic Access)}
Baseando-se na técnica anteriormente descrita de utilizar um \textit{buffer} partilhado entre a ferramenta de monitorização e o controlador, existe uma evolução desta técnica que permite que a interface de rede partilhe um \textit{buffer} com a ferramenta de monitorização para que os pacotes passem directamente para esta.
Esta partilha é efectuada utilizando \textit{mmap} \textit{ring\_buffers} e \textit{DMA}.
Para se utilizar esta técnica é necessário que a interface de rede permita a utilização de memória partilhada e utilização de \textit{DMA}.

Nestas técnicas que utilizam um \textit{Ring\_Buffer} é necessário utilizar uma \textit{API} de forma a serem controlados os índices de leitura e escrita\cite{:IntroPF_RIDNADirecNICAcces}.

\paragraph*{Sistemas \textit{multi-core} e multi-processador}
Devido ao aparecimento de sistemas multi-core e multi-processador para o publico em geral, a paralelização de código ou a forma de tirar partido destas arquitecturas para permitir um melhor aproveitamento dos recursos, parece interessante. 
De forma a tirar partido dos multi-core é necessário que controlador de rede, interfaces de rede, \textit{buffers}, controladores de \textit{DMA} (\textit{Direct Memory Access}), sejam modificados de forma a terem conhecimento da arquitectura. Como se pode constatar, é necessário um esforço conjunto de modo a tirar o máximo proveito destas arquitecturas\cite{Deri:2010}.


% \paragraph*{}
% Utilização de DCA (Direct Cache Access) E RSS (Receive Side Scaling) e TNAPI (Threaded NAPI)


\subsection{Formas de melhorar a performance dos filtros dinâmicos}
 O dinamismo das aplicações nomeadamente das aplicações multimédia, deu origem a diversos estudos sobre a forma de monitorização de rede que estes programas necessitam.
Estas aplicações utilizam diversos fluxos de dados, quer de transmissão que de recepção. Em geral, as aplicações multimédia, com base na \textit{internet} utilizam uma metodologia cliente/servidor, onde o servidor fica à espera de pedidos do cliente num determinado porto (pré-definido). O cliente como conhece à partida este porto liga-se. A partir deste ponto, começam as trocas de informações que irão dar origem à troca de portos dinâmicos, para posteriormente dar-se inicio ao processo de transmissão/recepção de dados multimédia.

As aplicações multimédia assentes na \textit{internet} são apenas um exemplo de aplicações com diversos fluxos e em que as portas de comunicação entre as aplicações são negociadas dinamicamente.

Como foi descrito anteriormente em \ref{sect:LibPcap}, a captura de pacotes é definida em filtros estáticos.
Para capturar este tipo de tráfego é necessário modificar os filtros definidos, de modo a acompanhar o protocolo.
Esta forma de captura é bastante ineficiente e, para tal, foram estudadas algumas alternativas. Os projectos \textit{mmdump}\cite{505678}, %\textit{Fairly Fast Packet Filters (FFPF)}\cite{1251278} 
e \textit{Swift}\cite{1387609} são dois destes casos estudados.

\paragraph*{MMDump} É uma ferramenta de monitorização de protocolos multimédia com suporte na rede.
Esta aplicação tem como base o \textit{tcpdump}, sendo a captura de pacotes efectuada através da utilização de filtros.
Para determinar que portos obter é necessário verificar o conteúdo dos pacotes direccionados a portos específicos e, a partir destes, é que é possível saber os novos portos negociados dinamicamente pela aplicação e alterar o filtro a aplicar. 

Como a alteração, cópia do novo filtro para o núcleo e verificação de segurança de forma a validá-lo é um processo pesado e por isso foi necessário minimizar este tempo de forma a ter uma aplicação que conseguisse minimizar o grau de perturbação no sistema.
Foi verificado que existe um certo padrão na forma de alteração do filtro.
A forma encontrada foi pré-estabelecer uma parte comum a ser adicionada ao filtro e apenas alterar a parte referente aos portos.

Esta forma de monitorização é muito especifica, tendo que se conhecer todo o protocolo interno de comunicação.
Assim, para cada novo protocolo que se queira monitorizar, é necessário acrescentar um novo módulo com a interpretação desse protocolo.

% \paragraph*{\textit{Fairly Fast Packet Filter} (FFPF)}

\paragraph*{\textit{Swift}}
\textit{Swift} é uma ferramenta de criação de filtros que tem como principal objectivo a melhoria do desempenho da utilização destes, na captura de tráfego de rede.
Neste trabalho foi avaliado o tempo de alteração dos filtros utilizando o \textit{Linux Socket Filtering}, pois estes são os filtros de referência em no sistema de operação \textit{Gnu Linux}.
A aplicação destes filtros a partir da biblioteca \textit{LipPcap} compreende três fases: cópia do filtro definido em nível utilizador para o núcleo de sistema, verificação de segurança, e aplicação do filtro.
De forma a diminuir a latência de actualização dos filtros criaram uma especificação de filtros de modo que estes não tivessem que ser analisados em termos de segurança, a própria linguagem garante as propriedades de segurança necessárias.
Com este novo \textit{instruction set} e sem a necessidade de verificação conseguiram diminuir a latência de actualização de filtros, permitindo assim um aumento da performance na utilização de filtros dinâmicos.

\section{Captura de tráfego de um processo utilizando monitorização da estrutura de rede}\label{sect:outras_abordagens}

A captura do tráfego respeitante a um processo, foi alvo de estudo em \cite{1688981} e em \cite{Farruca:2009}, esta última uma dissertação de mestrado. 

No primeiro trabalho foi desenvolvido um sistema de captura dos pacotes de um determinado processo, utilizando um módulo no núcleo de sistema que intercepta e obtém os pacotes de e para um determinado processo.

Este sistema é composto por três partes essenciais, uma dentro do núcleo de sistema e outras duas em nível utilizador.
Como o título do trabalho indica, foi utilizado a ferramenta \textit{KProbes} para a monitorização de algumas funções dentro do núcleo de sistema \textit{Linux}, de forma a obter quais os portos que uma determinada aplicação iria utilizar.
Após obtida a informação sobre o porto, esta é enviada para um processo em nível utilizador que tem o registo de todos os portos que estão a ser utilizados pela aplicação a monitorizar.
Se esse porto ainda não estiver a ser monitorizado, então essa informação é passada a outro processo que utiliza a biblioteca \textit{LibPcap} de forma a captura o tráfego existente nesse porto.


\begin{figure}[h!]
       \centering
       \includegraphics[height=2in]{captura_kprobes_paper}
       \caption{Arquitectura da monitorização de tráfego}
	\label{fig:paper_capture_kprobes}
\end{figure}


Como se pode ver na figura ~\ref{fig:paper_capture_kprobes}, o ACAP\_Collector e o ACAP\_Capturer estão em nível utilizador, o que sugere que se consiga aumentar a performance desta ferramenta caso esta seja completamente implementada dentro do núcleo de sistema de operação.

No segundo trabalho foram implementadas duas abordagens, uma com monitorização da aplicação e outra através de informações pertencentes ao núcleo do sistema de operação.

O núcleo de sistema do \textit{Linux} tem a informação sobre quais os portos de comunicação que uma aplicação tem com o exterior e permite que estes dados sejam consultados através do sistema de ficheiros virtual \textit{ProcFs} apresentado em \ref{cap:ProcFs_overview}.
Uma das formas de monitorização foi consultar estes dados de forma regular, com intervalos reduzidos.
Esta forma de monitorização consome demasiados recursos e não é 100\% fiável e quanto menor o intervalo de tempo que se utilizar, maior a perturbação que o sistema tem.
A outra abordagem efectuada foi de interceptar às chamadas à bibiloteca \textit{LibC} para a utilização de \textit{sockets}, criando uma bibiloteca partilhada com a mesma sintaxe das chamadas que são utilizadas.
Para utilizar este método é necessário definir a variável de ambiente \textit{LD\_PRELOAD} de forma a fazer esta intercepção.
Como esta biblioteca está em nível utilizador é necessário capturar todos os pacotes e apenas em nível utilizador visualizar o tráfego respeitante ao processo.
Capturar todos os pacotes pode ser uma tarefa com um elevado grau de perturbação do sistema. 

\section{Outros projectos}

Falta falar do ipt\_owner do iptables entre outros ....


\section{Outras alternativas splice e tee}

falta falar destas duas chamadas ao sistema importantes na redução do overhead na parte de desempenho

\section{Monitorização em nível utilizador}

Falta falar sobre ptrace LDPRELOAD, procfs, etc conjugar a informação completa ... falta falar que estão em continuação a tentativa de modificar o recurso ao ptrace atraves do utrace ... 
