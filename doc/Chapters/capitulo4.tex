\chapter{Estrutura}
\label{cap:Estrutura}


Neste capitulo vai ser apresentado parte da arquitectura de rede do núcleo do \textit{Linux}, bem como a arquitctura do projecto efectuado.

A arquitectura de rede do núcleo do \textit{Linux} poderá ser apresentada de duas formas, \textit{Bottom-Top} ou \textit{Top-Bottom}. A escolha recaíu sobre a primeira pois permite observar o aumento da complexidade e abstracção existente nesta arquitectura. 

\section{Arquitectura de rede do núcleo}

Falar aqui sobre qq coisa da estrutura de rede ... 
Talvez tb imagem com um pouco da arquitectura ... básica 

Falta falar sobre o netfilter ... sobre tc trafic control

\subsection{Recepção de dados}

A chegada de um pacote de dados à interface de rede desencadeia uma acção de interrupção da actividade do processador, permitindo quer este seja transferido para o sistema o mais cedo possível. Esta interrupção é efectuada através de um \textit{irq} pré-definido entre o controlador e a interface de rede. As interrupções são atendidas no processador desligando a atenção a todas as outras interrupções provenientes de outros dispositivos. %esta frase está ruim ...
O processador deve estar o menor intervalo de tempo possível com as interrupções desligadas, antes de retornar da interrupção o sistema agenda a execução de uma função que irá terminar a recepção do pacote para a camada correcta da \textit{stack TCP/IP}.%ainda falta falar sobre DMA, interrupt mode too exclusive deve ser breve, encaminhar pelo processamento da stack tcp/ip 

No processo de recepção da \textit{frame} é verificado se existem \textit{sniffers} registados, caso existam é passada uma referência sobre a frame, de forma a efectuar apenas a cópia da frame quando necessária. Esta situação é devida à possível existência de um filtro sobre a \textit{frame}, em que se não for necessário capturá-la, a cópia dos dados seja desnecessária, permitindo efectuar trabalho útil.

%Faltar falar que a frame segue para a stack tcp ip de forma normal ...

%Falta falar sobre o netfilter ... firewall do linux que existem 5 pontos de "entrada" onde existe algumas verificações .... 

% Faltar indicar que o processo está bloqueado à espera de input que lhe é copiado entre o nucleo e o processo em nivel utilizador por meio de o kiovec (talvez kernel io vector ...) 


\subsection{Transmissão de dados}

Uma aplicação em nível utilizador transfere dados sobre a rede através de chamadas ao sistema de operação, sendo que estas podem ser \textit{send}, \textit{sendto}, \textit{sendmsg}. Neste ponto de entrada os dados tem de ser copiados e efectuadas diversas verificações sobre estes, após estas verificações são utilizadas estruturas e funções através da \textit{stack TCP/IP} e fluir pela \textit{firewall netfilter}. Os dados gerados pelas diversas camadas da \textit{stack} são agregados numa estrutura \textit{sk\_buffer} para ser adicionados a uma fila para ser enviados pela ferramenta \textit{traffic control}. Quando esta ferramenta irá enviar os dados para o controlador é passada a referência sobre este pacote para os \textit{sniffers} registados, sendo apenas efectuada uma cópia dos dados caso o pacote seja recolhido para maior análise. Os dados passados ao controlador da interface de rede são então transferidos para a interface de rede e daí para o seu destino.

\section{Arquitectura do módulo desenvolvido}

A arquitectura foi pensada para ser executada de forma ortogonal ao sistema
utilizado. Desta forma não existe a necessidade de recompilar programas
antigos. Para além desta situação novas aplicações podem utilizar esta
ferramenta de forma transparente.

Esta ferramenta foi desenvolvida para os processadores x86 e x86\_64 pois nestas
arquitecturas existe suporte para o sistema de monitorização KProbes \ref{},
sendo esta a unica dependência especifica que a ferramenta irá ter.

As diferentes partes da ferramenta foram desenvolvidas de forma a poderem ser
modificadas em separado permitindo um melhor aproveitamento da modularização.
Este módulo foi desenvolvido em 4 subpartes. 

\section{Módulos no espaço do núcleo}
%a não utilização de ioctl para o debug ... 
A estratégia foi separar os diferentes componentes e a criação de um módulo de \textit{debug} para que pudesse existir uma forma de acesso à monitorização por parte do nível de utilizador, sem que exista a necessidade de criar ou alterar chamadas ao sistema ou suas opções.

\section{Filtro}

Para continuar a ser opaco para os diferentes sistemas de monitorização/captura de rede foi necessário colocar um ponto de ligação entre o sistema actual e o módulo desenvolvido. Quando não existe uma ligação efectuada, existe apenas um ligeiro decréscimo do desempenho, este deve-se à verificação da existência de ligação. Caso a ligação esteja activa o fluxo de controlo é passado para a função de filtro definida no módulo.

%Necessidade de registar um \textit{hook} para aceder directamente à função de
%filtro. Caso este \textit{hook} não esteja ligado o \textit{overhead}
%introduzido será o de um teste para verificar se existe ligação ou não.
%No caso de não existir a ligação a este \textit{hook} o sistema comporta-se de
%forma a utilizar apenas o sistema anterior.

\paragraph{Estruturas}

A não criação de novas estruturas de dados, foi devido à existência das
estruturas de dados existentes no código do núcleo do sistema de operação
linux, que já foram bastante analisadas e existem com o propósito de serem
utilizadas por outros programadores.

\paragraph{Divisão do módulo} 

O módulo subdivide-se em 4 partes, a monitorização, o ``reservatório'' de
informação, o \textit{hook} da ligação com o \textit{bpf} e
comunicação/\textit{debug}.

\paragraph{Interacção com o LSF}
O sistema interage também com o \textit{LSF} pois existe uma conjunção
entre o filtro definido pelo utilizador e a captura do tráfego da aplicação a
ser monitorizada.

\section{Desenho da Arquitectura}



\subsection{Monitorização da aplicação}

Como foi apresentado no quadro \ref{tab:monitoring} o sistema de monitorização
do núcleo do sistema linux que se adapta melhor para este problema é o
KProbes\ref{sec:kprobes}. 

\subsection{Repositório de dados}

Para permitir a consulta dos pares número de porta endereço é necessário
utilizar um repositório de dados. Este repositório de dados necessitará de alta
performance mas facilidade de utilização e modificação. Terá de permitir as
seguintes operações: adição, consulta e remoção de dados.

Este repositório de dados irá ser a ponte entre o sistema de  monitorização e o
sistema de filtragem de pacotes. 

\subsection{Filtragem de pacotes}

Sistema que irá indicar à função run\_filter do \textit{LSF} se um pacote deverá
ser capturado ou não. Irá ser definido um ponto \textit{hook} dentro do núcleo
do sistema do linux, de forma a poder ser utilizada a funcionalidade de
filtragem dinâmica apenas quando se deseje. O custo introduzido para estas
modificação é apenas de uma verificação se o \textit{hook} está ligado ou não.


\subsection{Recolha de informações}

Utilizando um dos sistemas definidos em \ref{tab:transferencia_dados} é
permitido o acesso a informações de análise dos diversos sistemas anteriormente
mencionados.


\section{Arquitectura de Rede do Linux}

Desde que os dados saem da aplicação até chegarem ao controlador da interface
de rede. 
% Imagem dos dados 

\subsection{AF\_PACKET}

A forma para comunicar enviar e receber dados directamente da interface de rede
é através da familia de protocolos \textit{AF\_PACKET}. 

Esta é a forma de implementar protocolos de rede sem recorrer à \textit{stack}
de protocolos IP em nível utilizador. Para além desta funcionalidade esta é a
forma de capturar os pacotes que circulam na interface de rede, permitindo
assim efectuar uma análise do tráfego.

Esta camada situa-se junto aos controladores de rede permitindo assim capturar
dados que podem não chegar às aplicações devido à utilização de regras na
\textit{firewall} (netfilter) do \textit{linux}.

A utilização de ``lazy cloning'' permite que apenas os pacotes que sejam para
capturar sejam efectivamente copiados. Por isso primeiro são avaliados para o
processo de captura, caso sejam para captura a função \textit{blah blah}
efectua a cópia da estrutura sk\_buffer e serão então adicionados ao
\textit{ring buffer}. Se no \textit{ring buffer} não existir espaço para o
número de bytes que devem ser capturados, é então descartado a cópia
(libertado o espaço) e incrementado o valor de pacotes descartados pelo núcleo
de sistema.


\subsection{Subsistema de rede} % falta melhor nome ...
\label{subsection:network}
Socket  e o que é um socket ...

Os ``file descriptors'' são a abstração para os ``sockets''. Os sockets são
mapeados em ficheiros e estes em descritores de ficheiros. 

Dentro do núcleo do linux a estrutura que tém a informação sobre um processo
(\textit{task}), é a \textit{struct task\_struct}. Nesta estrutura existe a
informação sobre quais os ficheiros que a aplicação abriu. Como os
\textit{sockets} são mapeados sob a forma de ficheiros, estes também se
encontram nesta estrutura.

Os protocolos \textit{TCP} e \textit{UDP} foram os únicos protocolos que se teve
interesse em utilizar nesta ferramenta.

Estes protocolos estão definidos numa estrutura de apontadores para funções.
Os protocolos \textit{TCP} e \textit{UDP} têm formas diferentes de executar
funcionalidades semelhantes e por isso estão descritos em instâncias diferentes.

As principais chamadas ao sistema para estabelecer, terminar e transferir dados
sobre \textit{sockets} são: \textit{socket}, \textit{connect}, \textit{bind},
\textit{listen}, \textit{accept}, \textit{send}, \textit{recv}, \textit{sendto},
\textit{recvfrom} e \textit{close}. 

Estas chamadas aos sistema são genéricas de forma a poderem ser mapeadas nas
diferentes instâncias dos protocolos de transferência

Quando a chamada ao sistema \textit{socket} é efectuada, é criado uma nova
instância de um socket e inicializados os respectivos campos com a informação
dependente para a familia e tipo. 

%  Descrever um pouco esta parte ...

Como os protocolos \textit{TCP} e \textit{UDP} partilham algumas das
funcionalidades nem todas as f

\subsection{Interfaces de rede}

O núcleo do \textit{linux} mantém a informação sobre quais as interfaces de
rede que foram inicializadas pelos seus controladores, mesmo que não estando
activas estas constantam de uma lista duplamente ligada de
\textit{net\_devices}. Em cada posição da lista está toda a informação
referente a uma interface de rede e suas configurações, nomeadamente a
informação sobre o seu endereço ip ou o seu mac address no caso de interfaces
\textit{ethernet} ou mapeadas sobre \textit{ethernet} (como o caso das
interfaces ponto-a-ponto).


\section{Temporizadores}

Temporizadores no núcleo do sistema.


\subsection{Temporizadores de Alta-Resolução}

\textit{HrTimer}

